<!DOCTYPE html><html lang="zh-cn" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>最短路算法 · Steven's blog</title><meta name="description" content=""><meta name="og:title" content="最短路算法"><meta name="og:type" content="website"><meta name="og:url" content="http://example.com/2022/05/21/最短路/"><meta name="og:image" content="http://image.toast.com/aaaaahq/hola_cover.JPG"><meta name="og:description" content=""><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/chiangmai.css"><meta name="steem:author" content="@stunstunstun"><meta name="fb:app_id" content="1258629384258634"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="Steven's blog"><meta name="generator" content="Hexo 6.1.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Steven's blog" type="application/atom+xml">
</head><body class="post"><div id="fb-root"></div><div class="wrap"><header><nav class="navi-post"><a class="navi-post-back" href="javascript:history.back()"><i class="fa fa-arrow-left" aria-hidden="true"></i></a><a class="navi-post-home" href="/"><i class="fa fa-home" aria-hidden="true"></i></a></nav></header><main class="post"><div class="post"><article class="post-block"><h1 class="post-title">最短路算法</h1><div class="post-info"><div class="post-info-profile"><a href="https://github.com/stunstunstun" target="_blank"><img src="/image/profile.jpg"></a></div><div class="post-info-details"><div class="post-categories"><a href="/categories/%E6%8A%80%E6%9C%AF" target="_self"><span>技术</span></a></div><div class="post-date">2022年5月21日</div></div></div><div class="post-share"><div class="fb-like" data-href="http://example.com/2022/05/21/最短路/" data-layout="button_count" data-action="like" data-size="small" data-show-faces="true" data-share="false">                 </div><div class="fb-share-button" data-href="http://example.com/2022/05/21/最短路/" data-layout="button" data-size="small" data-mobile-iframe="true"></div><div class="fb-follow" data-href="https://www.facebook.com/holaxprogramming/" data-layout="button_count" data-size="small" data-show-faces="true"></div></div><div class="post-content"><h1 id="最短路"><a class="markdownIt-Anchor" href="#最短路"></a> 最短路</h1>
<p>声明：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个点，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">m</span></span></span></span> 条边<br />
稠密图用邻接矩阵，稀疏图用邻接表</p>
<p><img src="https://s2.loli.net/2022/03/24/UQgtY4E9yblsL75.png" alt="" /></p>
<h3 id="dijkstra算法"><a class="markdownIt-Anchor" href="#dijkstra算法"></a> dijkstra算法</h3>
<p>不适用于有负权边的情况，复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 或 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>⋅</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m\cdot logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></p>
<p>有朴素版本和堆(优先队列)优化版本</p>
<h4 id="朴素版本"><a class="markdownIt-Anchor" href="#朴素版本"></a> 朴素版本</h4>
<pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span>
</span>&#123;
    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));
    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i ++ )  <span class="hljs-comment">// 因为第一个点已经计算过了，所以循环n-1次即可</span>
    &#123;
        <span class="hljs-type">int</span> t = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )
            <span class="hljs-keyword">if</span>(!st[j] &amp;&amp; (t == <span class="hljs-number">-1</span> || dist[j] &lt; dist[t]))
                    t = j;

        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )
            dist[j] = <span class="hljs-built_in">min</span>(dist[j], dist[t] + g[t][j]); 
        st[t] = <span class="hljs-literal">true</span>;
    &#125;
    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];
&#125;
</code></pre>
<h4 id="堆优化版本"><a class="markdownIt-Anchor" href="#堆优化版本"></a> 堆优化版本</h4>
<p>(优化的是找出距离最近的点这一步)</p>
<pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span>  <span class="hljs-comment">// 邻接表存边</span>
</span>&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span>
</span>&#123;
    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));  <span class="hljs-comment">//  初始化距离为正无穷</span>
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;  <span class="hljs-comment">// 元素种类为PII的小根堆</span>
    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
    heap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));  <span class="hljs-comment">//  由于小根堆中的pair会默认按第一个元素排序，所以这里将距离存到前面</span>
    <span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())
    &#123;
        <span class="hljs-keyword">auto</span> t = heap.<span class="hljs-built_in">top</span>();
        heap.<span class="hljs-built_in">pop</span>();
        <span class="hljs-type">int</span> distance = t.first, ver = t.second;
        <span class="hljs-keyword">if</span>(st[ver]) <span class="hljs-keyword">continue</span>;
        st[ver]  = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i] )  <span class="hljs-comment">//  注意i初始化ver的头指针h[ver]</span>
        &#123;
            <span class="hljs-type">int</span> j = e[i];  <span class="hljs-comment">// 取点</span>
            <span class="hljs-keyword">if</span>(distance + w[i] &lt; dist[j]) 
            &#123;
                dist[j] = distance + w[i];
             heap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(dist[j], j));
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">if</span>(dist[n] == <span class="hljs-number">0x3f3f3f3f</span>)  <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> dist[n];
&#125;
</code></pre>
<h4 id="vector存图"><a class="markdownIt-Anchor" href="#vector存图"></a> vector存图</h4>
<pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cout &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> xx first</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> yy second</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;
<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">5</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;
<span class="hljs-comment">//const double esp = 1e-6;</span>
<span class="hljs-type">int</span> dist[N];
<span class="hljs-type">bool</span> st[N];
<span class="hljs-type">int</span> n, m;
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    cin &gt;&gt; n &gt;&gt; m;
    vector&lt;vector&lt;PII&gt;&gt; <span class="hljs-built_in">g</span>(n);
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++)
    &#123;
        <span class="hljs-type">int</span> a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        a --, b --;
        g[a].<span class="hljs-built_in">push_back</span>(&#123;b, c&#125;);
    &#125;
    <span class="hljs-keyword">auto</span> dijkstra = [&amp;]()
    &#123;
        <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-keyword">sizeof</span> dist);
        <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);
        priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; q;
        dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;
        q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);
        <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())
        &#123;
            <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>();
            q.<span class="hljs-built_in">pop</span>();
            <span class="hljs-keyword">if</span>(st[t.yy]) <span class="hljs-keyword">continue</span>;
            st[t.yy] = <span class="hljs-literal">true</span>; 
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> [u, v] : g[t.yy])
            &#123;
                <span class="hljs-keyword">if</span>(dist[u] &gt; t.xx + v)
                &#123;
                    dist[u] = t.xx + v;
                    q.<span class="hljs-built_in">push</span>(&#123;dist[u], u&#125;);
                &#125;
            &#125;
        &#125;
    &#125;;
    <span class="hljs-built_in">dijkstra</span>();
    <span class="hljs-keyword">if</span>(dist[n - <span class="hljs-number">1</span>] == <span class="hljs-number">0x3f3f3f3f</span>) cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span>;
    <span class="hljs-keyword">else</span> cout &lt;&lt; dist[n - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

</code></pre>
<h4 id="邮递员送信"><a class="markdownIt-Anchor" href="#邮递员送信"></a> 邮递员送信</h4>
<p>邮递员去送信然后要求送信后再返回（有向边）</p>
<p>解法：</p>
<p>反向建边+跑两次dijkstra<br />
正着走过去的时候用一遍dijkstra。<br />
返回时就建个返图跑一遍dijkstra。<br />
反图可以把所有结点的编号+n建在原图的体系中。</p>
<pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;  <span class="hljs-comment">//  数组记得开够</span>
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> h[N], ne[N], w[N], e[N], idx;
<span class="hljs-type">int</span> dist[N];
<span class="hljs-type">bool</span> st[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span>
</span>&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> fir)</span>
</span>&#123;   
    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt;heap;
    dist[fir] = <span class="hljs-number">0</span>;
    heap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, fir));
    <span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())
    &#123;
        PII t = heap.<span class="hljs-built_in">top</span>();
        heap.<span class="hljs-built_in">pop</span>();
        <span class="hljs-type">int</span> distance = t.first, ver = t.second;
        <span class="hljs-keyword">if</span>(st[ver])  <span class="hljs-keyword">continue</span>;
        st[ver] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])
        &#123;
            <span class="hljs-type">int</span> j = e[i];
            <span class="hljs-keyword">if</span>(dist[j] &gt; distance + w[i])
            &#123;
                dist[j] = distance + w[i];
                heap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(dist[j], j));
            &#125;
        &#125;
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));
    <span class="hljs-keyword">while</span>(m -- )
    &#123;
        <span class="hljs-type">int</span> a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        <span class="hljs-built_in">add</span>(a, b, c);
        <span class="hljs-built_in">add</span>(b + n, a + n, c);  <span class="hljs-comment">//  建一个反图</span>
    &#125;
    <span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span>);
    LL res = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )
    &#123;
        res += dist[i];
    &#125;
    <span class="hljs-built_in">dijkstra</span>(<span class="hljs-number">1</span> + n);  <span class="hljs-comment">//  反向跑一次dijkstra</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> + n; i &lt;= <span class="hljs-number">2</span> * n; i ++ )
    &#123;
        res += dist[i];
    &#125;
    cout &lt;&lt; res;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre>
<h4 id="最短路计数"><a class="markdownIt-Anchor" href="#最短路计数"></a> 最短路计数</h4>
<p>增加一个num数组进行计数</p>
<pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;
<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e6</span> + <span class="hljs-number">5</span>, mod = <span class="hljs-number">100003</span>;
<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> h[N], ne[N], w[N], e[N], idx;
<span class="hljs-type">int</span> dist[N], num[N];
<span class="hljs-type">bool</span> st[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span>
</span>&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">()</span>
</span>&#123;
    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));
    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
    num[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;
    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;
    heap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>));
    <span class="hljs-keyword">while</span>(heap.<span class="hljs-built_in">size</span>())
    &#123;
        PII t = heap.<span class="hljs-built_in">top</span>();
        heap.<span class="hljs-built_in">pop</span>();
        <span class="hljs-type">int</span> distance = t.first, ver = t.second;
        <span class="hljs-keyword">if</span>(st[ver]) <span class="hljs-keyword">continue</span>;
        st[ver] = <span class="hljs-literal">true</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[ver]; i != <span class="hljs-number">-1</span>; i = ne[i])
        &#123;
            <span class="hljs-type">int</span> j = e[i];
            <span class="hljs-keyword">if</span>(dist[j] == distance + w[i])
            &#123;
                num[j] = (num[j] + num[ver]) % mod;
            &#125;
            <span class="hljs-keyword">if</span>(dist[j] &gt; distance + w[i])
            &#123;
                dist[j] = distance + w[i];
                num[j] = num[ver];
                heap.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(dist[j], j));
            &#125;
        &#125;
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));
    <span class="hljs-keyword">while</span>(m -- )
    &#123;
        <span class="hljs-type">int</span> a, b;
        cin &gt;&gt; a &gt;&gt; b;
        <span class="hljs-keyword">if</span>(a == b) <span class="hljs-keyword">continue</span>;
        <span class="hljs-built_in">add</span>(a, b, <span class="hljs-number">1</span>);
        <span class="hljs-built_in">add</span>(b, a, <span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-built_in">dijkstra</span>();
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )
    &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, num[i]);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre>
<h3 id="bellman-ford算法"><a class="markdownIt-Anchor" href="#bellman-ford算法"></a> Bellman-ford算法</h3>
<p>适用于有负权边的情况</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \cdot m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p>
<p>如果有负环，或限制最多走k次时可以用，大多数时候用SPFA完全替代</p>
<pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>, M = <span class="hljs-number">10010</span>;

<span class="hljs-type">int</span> n, m, k;  <span class="hljs-comment">//  n个点，m条边，走不超过k次</span>

<span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>
&#123;
    <span class="hljs-type">int</span> a, b, c;
&#125;edge[M];

<span class="hljs-type">int</span> dist[N], backup[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bellman_ford</span><span class="hljs-params">()</span>
</span>&#123;
    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));
    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i ++ )
    &#123;
        <span class="hljs-built_in">memcpy</span>(backup, dist, <span class="hljs-built_in">sizeof</span>(dist));
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )
        &#123;
            Edge e = edge[j];
            dist[e.b] = <span class="hljs-built_in">min</span>(dist[e.b], backup[e.a] + e.c);
        &#125;
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )
    &#123;
        <span class="hljs-type">int</span> a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        edge[i].a = a, edge[i].b = b, edge[i].c = c;
    &#125;
    <span class="hljs-built_in">Bellman_ford</span>();
    <span class="hljs-keyword">if</span>(dist[n] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;impossible\n&quot;</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dist[n]);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre>
<h3 id="spfa算法"><a class="markdownIt-Anchor" href="#spfa算法"></a> SPFA算法</h3>
<p>利用宽搜BFS进行优化</p>
<p>适用于有负权边的情况</p>
<p>如果存在负环则不能用</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>，最坏情况<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n\cdot m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p>
<h4 id="朴素版本-2"><a class="markdownIt-Anchor" href="#朴素版本-2"></a> 朴素版本</h4>
<pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;

<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> e[N], w[N], ne[N], h[N], idx;
<span class="hljs-type">int</span> dist[N];
<span class="hljs-type">bool</span> st[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span>
</span>&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span>
</span>&#123;
    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));
    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;

    queue&lt;<span class="hljs-type">int</span>&gt; q;
    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);
    st[<span class="hljs-number">1</span>] = <span class="hljs-literal">true</span>;

    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())
    &#123;
        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();
        q.<span class="hljs-built_in">pop</span>();
        st[t] = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])  <span class="hljs-comment">// i = h[t]忘记写h了易错！！！</span>
        &#123;
            <span class="hljs-type">int</span> j = e[i];
            <span class="hljs-keyword">if</span>(dist[j] &gt; dist[t] + w[i])
            &#123;
                dist[j] = dist[t] + w[i];
                <span class="hljs-keyword">if</span>(!st[j])
                &#123;
                    q.<span class="hljs-built_in">push</span>(j);  <span class="hljs-comment">//  记得推进队列之中去</span>
                    st[j] = <span class="hljs-literal">true</span>;
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> dist[n];
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    cin &gt;&gt; n &gt;&gt; m;
    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);
    <span class="hljs-keyword">while</span>(m -- )
    &#123;
        <span class="hljs-type">int</span> a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        <span class="hljs-built_in">add</span>(a, b, c);
    &#125;
    <span class="hljs-type">int</span> t = <span class="hljs-built_in">spfa</span>();
    <span class="hljs-keyword">if</span>(t == <span class="hljs-number">0x3f3f3f3f</span>)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;impossible\n&quot;</span>);
    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, t);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

</code></pre>
<h4 id="spfa判断负环"><a class="markdownIt-Anchor" href="#spfa判断负环"></a> SPFA判断负环</h4>
<pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;

<span class="hljs-type">int</span> n, m;
<span class="hljs-type">int</span> h[N], e[N], ne[N], w[N], idx;
<span class="hljs-type">int</span> dist[N];
<span class="hljs-type">int</span> cnt[N];
<span class="hljs-type">bool</span> st[N];

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c)</span>
</span>&#123;
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
&#125;

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">()</span>
</span>&#123;
    <span class="hljs-built_in">memset</span>(dist, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(dist));
    <span class="hljs-built_in">memset</span>(cnt, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(cnt));
    queue &lt;<span class="hljs-type">int</span>&gt; q;
    dist[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;
    <span class="hljs-comment">//  如果题目说存在负环，那么需要循环一次将所有的点都加入队列之中</span>
    <span class="hljs-comment">//  如果是求是否存在从1开始的负环，那么只将1加入队列之中就可以了</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )
    &#123;
        q.<span class="hljs-built_in">push</span>(i);   
        st[i] = <span class="hljs-literal">true</span>;
    &#125;
    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())
    &#123;
        <span class="hljs-type">int</span> t = q.<span class="hljs-built_in">front</span>();
        q.<span class="hljs-built_in">pop</span>();
        st[t] = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[t]; i != <span class="hljs-number">-1</span>; i = ne[i])
        &#123;
            <span class="hljs-type">int</span> j = e[i];
            <span class="hljs-keyword">if</span>(dist[j] &gt; dist[t] + w[i])
            &#123;
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + <span class="hljs-number">1</span>; 
                <span class="hljs-keyword">if</span>(cnt[j] &gt;= n)  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">if</span>(!st[j])
                &#123;
                    q.<span class="hljs-built_in">push</span>(j); 
                    st[j] = <span class="hljs-literal">true</span>;
                &#125;
            &#125;
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    <span class="hljs-type">int</span> t;
    cin &gt;&gt; t;
    <span class="hljs-keyword">while</span>(t -- )
    &#123;
        <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-built_in">sizeof</span>(h));
        <span class="hljs-built_in">memset</span>(e, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(e));
        <span class="hljs-built_in">memset</span>(ne, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(ne));
        <span class="hljs-built_in">memset</span>(w, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(w));
        <span class="hljs-built_in">memset</span>(st, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(st));
        idx = <span class="hljs-number">0</span>;
        cin &gt;&gt; n &gt;&gt; m;
        <span class="hljs-keyword">while</span>(m -- )
        &#123;
            <span class="hljs-type">int</span> a, b, w;
            cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;
            <span class="hljs-keyword">if</span>(w &gt;= <span class="hljs-number">0</span>)
            &#123;
                <span class="hljs-built_in">add</span>(a, b, w);
                <span class="hljs-built_in">add</span>(b, a, w);
            &#125;
            <span class="hljs-keyword">else</span>  <span class="hljs-built_in">add</span>(a, b, w); 
        &#125;
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">spfa</span>())  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre>
<p>用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo stretchy="false">[</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">cnt[]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mclose">]</span></span></span></span> 数组进行判断，如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><mi>t</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">cnt[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span> 大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 说明存在负环使得求最短路时不断循环</p>
<p>时间复杂度 一般：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span> 最坏：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nm)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></p>
<h3 id="多源汇最短路floyd算法"><a class="markdownIt-Anchor" href="#多源汇最短路floyd算法"></a> 多源汇最短路Floyd算法</h3>
<p>时间复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">300</span>;
<span class="hljs-type">int</span> n, m, k;
<span class="hljs-type">int</span> dist[N][N];  <span class="hljs-comment">//  注意只需要dist数组，无需g数组</span>

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span>
</span>&#123;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; k ++ )  <span class="hljs-comment">// k写在最前面</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )
            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )
                dist[i][j] = <span class="hljs-built_in">min</span>(dist[i][j], dist[i][k] + dist[k][j]);  
    <span class="hljs-comment">// 注意是dist[i][k]+dist[k][j]</span>
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;
    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )
    &#123;
        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j ++ )
        &#123;
            <span class="hljs-keyword">if</span>(i == j)  dist[i][j] = <span class="hljs-number">0</span>;  <span class="hljs-comment">//  不用memset进行初始化</span>
            <span class="hljs-comment">//  手动初始化使得dist[i][i] = 0</span>
            <span class="hljs-keyword">else</span> dist[i][j] = <span class="hljs-number">0x3f3f3f3f</span>;
        &#125;
    &#125;
    <span class="hljs-keyword">while</span>(m -- )
    &#123;
        <span class="hljs-type">int</span> a, b, c;
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        dist[a][b] = <span class="hljs-built_in">min</span>(dist[a][b], c);  <span class="hljs-comment">// 重边最小化操作</span>
    &#125;
    <span class="hljs-built_in">floyd</span>(); 
    <span class="hljs-keyword">while</span>(k -- )
    &#123;
        <span class="hljs-type">int</span> a, b;
        cin &gt;&gt; a &gt;&gt; b;
        <span class="hljs-keyword">if</span>(dist[a][b] &gt; <span class="hljs-number">0x3f3f3f3f</span> / <span class="hljs-number">2</span>)  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;impossible\n&quot;</span>);
        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, dist[a][b]);
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2022/04/25/%E6%80%80%E5%BF%B52019/"><i class="fa fa-arrow-left" aria-hidden="true"></i></a><a class="next" href="/2022/05/21/%E6%95%B0%E8%AE%BA1/"><i class="fa fa-arrow-right" aria-hidden="true"></i></a></div><ins class="adsbygoogle adsense-bottom" style="display:block" data-ad-client="ca-pub-6188640546219653" data-ad-slot="6129396565" data-ad-format="auto"></ins><div class="fb-comments-area"><div class="fb-comments" data-href="http://example.com/2022/05/21/最短路/" data-width="700" data-numposts="5"></div></div><div class="copyright"><p>© 2012 - 2023 <a href="https://github.com/stunstunstun" target="_blank">Minhyeok Jung</a>. Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/stunstunstun/hexo-theme-chiangmai" target="_blank">hexo-theme-chiangmai</a>.</p></div></footer></div><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({});</script><script>window.fbAsyncInit=function(){FB.init({appId:"1258629384258634",cookie:!0,xfbml:!0,version:"v2.8"}),FB.AppEvents.logPageView()},function(e,n,t){var o,c=e.getElementsByTagName(n)[0];e.getElementById(t)||((o=e.createElement(n)).id=t,o.src="//connect.facebook.net/en_US/sdk.js",c.parentNode.insertBefore(o,c))}(document,"script","facebook-jssdk");</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create','UA-97419941-1','auto');ga('send','pageview');</script></body></html>