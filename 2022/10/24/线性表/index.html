<!DOCTYPE html><html lang="zh-cn" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>线性表 · Steven's blog</title><meta name="description" content=""><meta name="og:title" content="线性表"><meta name="og:type" content="website"><meta name="og:url" content="http://example.com/2022/10/24/线性表/"><meta name="og:image" content="http://image.toast.com/aaaaahq/hola_cover.JPG"><meta name="og:description" content=""><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/chiangmai.css"><meta name="steem:author" content="@stunstunstun"><meta name="fb:app_id" content="1258629384258634"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="Steven's blog"><meta name="generator" content="Hexo 6.1.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Steven's blog" type="application/atom+xml">
</head><body class="post"><div id="fb-root"></div><div class="wrap"><header><nav class="navi-post"><a class="navi-post-back" href="javascript:history.back()"><i class="fa fa-arrow-left" aria-hidden="true"></i></a><a class="navi-post-home" href="/"><i class="fa fa-home" aria-hidden="true"></i></a></nav></header><main class="post"><div class="post"><article class="post-block"><h1 class="post-title">线性表</h1><div class="post-info"><div class="post-info-profile"><a href="https://github.com/stunstunstun" target="_blank"><img src="/image/profile.jpg"></a></div><div class="post-info-details"><div class="post-categories"><a href="/categories/%E6%8A%80%E6%9C%AF" target="_self"><span>技术</span></a></div><div class="post-date">2022年10月24日</div></div></div><div class="post-share"><div class="fb-like" data-href="http://example.com/2022/10/24/线性表/" data-layout="button_count" data-action="like" data-size="small" data-show-faces="true" data-share="false">                 </div><div class="fb-share-button" data-href="http://example.com/2022/10/24/线性表/" data-layout="button" data-size="small" data-mobile-iframe="true"></div><div class="fb-follow" data-href="https://www.facebook.com/holaxprogramming/" data-layout="button_count" data-size="small" data-show-faces="true"></div></div><div class="post-content"><h3 id="定义与特点"><a class="markdownIt-Anchor" href="#定义与特点"></a> 定义与特点</h3>
<p>由n个类型相同的数据元素组成的有限序列</p>
<p>存在第一个数据元素和最后一个数据元素</p>
<p>除了第一个外每个元素都有一个前驱</p>
<p>除了最后一个之外每个元素都有一个后继</p>
<h3 id="顺序表示"><a class="markdownIt-Anchor" href="#顺序表示"></a> 顺序表示</h3>
<h5 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h5>
<pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 1024</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> ElemType;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;
	ElemType *elem;  <span class="hljs-comment">// 指向数据元素的基地址</span>
	<span class="hljs-type">int</span> length;  <span class="hljs-comment">// 当前长度</span>
&#125;Sqlist;  <span class="hljs-comment">// 顺序表</span>

<span class="hljs-comment">// 创建顺序表</span>
<span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;
    <span class="hljs-comment">// 分配空间</span>
    L.elem = <span class="hljs-keyword">new</span> ElemType[MAXSIZE];
    <span class="hljs-keyword">if</span> (L.elem == <span class="hljs-literal">NULL</span>) <span class="hljs-built_in">exit</span>(OVERFLOW);
    L.length = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> OK;
&#125;<span class="hljs-comment">// 时间复杂度 O(1)</span>

<span class="hljs-comment">// 销毁顺序表</span>
<span class="hljs-function">Status <span class="hljs-title">DestroyList</span><span class="hljs-params">(SqList &amp;L)</span></span>&#123;
    <span class="hljs-keyword">if</span>(L.elem != <span class="hljs-literal">NULL</span>) &#123;
        <span class="hljs-keyword">delete</span> []L.elem;  释放存储空间
        <span class="hljs-keyword">return</span> OK;
    &#125;
    <span class="hljs-keyword">return</span> ERROR;
&#125;<span class="hljs-comment">// 时间复杂度 O(1)</span>

<span class="hljs-comment">// 获取线性表中的元素值</span>
<span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(SqList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;
	<span class="hljs-comment">// 判断i值是否合理，若不合理，则返回ERROR</span>
    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L.length)  <span class="hljs-keyword">return</span> ERROR;
    e = L.elem[i<span class="hljs-number">-1</span>]; <span class="hljs-comment">// 将结果存储在e中</span>
    <span class="hljs-keyword">return</span> OK;
&#125;<span class="hljs-comment">// 时间复杂度 O(1)</span>

<span class="hljs-comment">// 在线性表中查找值为e的数据</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(SqList L, Elemtype e)</span></span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; L.length; i ++ )&#123;
        <span class="hljs-keyword">if</span>(L.elem[i] == e) 
            <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125; <span class="hljs-comment">// 时间复杂度 O(n)</span>

<span class="hljs-comment">// 在线性表的第i个数据元素的位置插入数据元素e</span>
<span class="hljs-function">Status <span class="hljs-title">ListInsert</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i, ElemType e)</span></span>&#123;
    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L.length + <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> ERROR;
    <span class="hljs-keyword">if</span> (L.length &gt;= MAXSIZE) <span class="hljs-keyword">return</span> ERROR;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = L.length - <span class="hljs-number">1</span>; j &gt;= i - <span class="hljs-number">1</span>; j -- )
        L.elem[j + <span class="hljs-number">1</span>] = L.elem[j];
   	L.elem[i - <span class="hljs-number">1</span>] = e;
    L.length ++ ;
    <span class="hljs-keyword">return</span> OK;
&#125;<span class="hljs-comment">// 时间复杂度 O(n)</span>

<span class="hljs-comment">// 在线性表L中的第i个元素删除</span>
<span class="hljs-function">Status <span class="hljs-title">ListDelete</span><span class="hljs-params">(SqList &amp;L, <span class="hljs-type">int</span> i)</span></span>&#123;
    <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">1</span> || i &gt; L.length) retunr ERROR;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; L.length; j ++ )  <span class="hljs-comment">// 元素前移</span>
        L.elem[j - <span class="hljs-number">1</span>] = L.elem[j];
   	L.length -- ; <span class="hljs-comment">// 表长减1</span>
    <span class="hljs-keyword">return</span> OK;
&#125;<span class="hljs-comment">// 时间复杂度 O(n)</span>
</code></pre>
<h5 id="顺序表的优缺点"><a class="markdownIt-Anchor" href="#顺序表的优缺点"></a> 顺序表的优缺点</h5>
<p>优点： 可随机访问， 存储空间使用紧凑</p>
<p>缺点： 插入删除需要大量移动元素， 预先分配空间按最大空间分配(可能造成空间的浪费，表的容量难以扩充)</p>
<h3 id="链式表示"><a class="markdownIt-Anchor" href="#链式表示"></a> 链式表示</h3>
<h5 id="基础概念"><a class="markdownIt-Anchor" href="#基础概念"></a> 基础概念</h5>
<p>用一组任意的存储单元存储线性表的数据元素</p>
<p>(可以不连续)</p>
<p>通过<strong>指针</strong>的指向来实现元素之间的相邻关系</p>
<p>额外存储一个后继节点的位置信息</p>
<p>每个数据元素存储的两部分信息合在一起被称为<strong>结点</strong></p>
<ul>
<li>数据元素内容被称作<strong>数据域</strong></li>
<li>后继元素地址被称为<strong>指针域</strong></li>
</ul>
<blockquote>
<p>最后一个节点的指针域为NULL</p>
</blockquote>
<p>头节点：为了简化操作，在链表的第一个数据结点前附加的结点</p>
<p>首元结点：第一个存储数据元素的结点</p>
<p>无论链表是否为空，头指针都是非空的！！</p>
<h5 id="代码实现-2"><a class="markdownIt-Anchor" href="#代码实现-2"></a> 代码实现</h5>
<pre class="highlight"><code class="c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span>&#123;
	ElemType data; <span class="hljs-comment">// 数据域</span>
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">LNode</span> *next;  <span class="hljs-comment">// 指针域</span>
&#125;LNode, *LinkList;
<span class="hljs-comment">// LinkList 为LNode类型的指针</span>

<span class="hljs-comment">// 链表的创建</span>
<span class="hljs-function">Status <span class="hljs-title">InitList</span><span class="hljs-params">(LinkList &amp;L)</span></span>&#123;
    LNode* L = <span class="hljs-keyword">new</span> LNode;
    <span class="hljs-comment">// if(L == NULL) exit(OVERFLOW);</span>
    L -&gt; next = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">return</span> OK;
&#125;

<span class="hljs-comment">// 链表的判空</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListEmpty</span><span class="hljs-params">(LinkList L)</span></span>&#123;
<span class="hljs-comment">// 若L为空表，则返回1，否则返回0</span>
    <span class="hljs-keyword">if</span> (L-&gt;next == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
   	<span class="hljs-keyword">else</span> 
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">// 链表的长度</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ListLength</span><span class="hljs-params">(LinkList L)</span></span>&#123;
	LNode* L = L-&gt;next;  <span class="hljs-comment">// p指向第一个结点</span>
    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(p)&#123;  <span class="hljs-comment">// 遍历单链表，统计结点个数</span>
        i ++ ;
        p = p-&gt;next;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
&#125;

<span class="hljs-comment">// 链表的取值</span>
<span class="hljs-function">Status <span class="hljs-title">GetElem</span><span class="hljs-params">(LinkList L, <span class="hljs-type">int</span> i, ElemType &amp;e)</span></span>&#123;
    LNode* p = L-&gt;next;
    <span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; <span class="hljs-comment">// 从首元结点开始查找</span>
    <span class="hljs-keyword">while</span>(p)&#123;
        <span class="hljs-keyword">if</span>(i == j)&#123;  <span class="hljs-comment">// 找到</span>
            e = p-&gt;data;
            <span class="hljs-keyword">return</span> OK;
        &#125;
        p = p -&gt; next;
        j ++ ;
    &#125;
    <span class="hljs-keyword">return</span> ERROR;
&#125;

<span class="hljs-comment">// 链表的查找</span>
<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LocateElem</span><span class="hljs-params">(LinkList L, ElemType e)</span></span>&#123;
    LNode* p = L-&gt;next;
    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;
    <span class="hljs-keyword">while</span>(p)&#123;
        <span class="hljs-keyword">if</span>(p-&gt;data == e) <span class="hljs-keyword">return</span> i;
        p = p-&gt;next;
        i ++ ;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;

<span class="hljs-comment">// 链表查找(返回地址)</span>
<span class="hljs-function">LNode* <span class="hljs-title">Find</span><span class="hljs-params">(LinkList L, ElemType e)</span></span>&#123;
    LNode* p = L-&gt;next;
    <span class="hljs-keyword">while</span>(p)&#123;
        <span class="hljs-keyword">if</span>(p-&gt;data == e) <span class="hljs-keyword">return</span> p;
        p = p-&gt;next;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
&#125;


<span class="hljs-comment">// 链表的输出</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintList</span><span class="hljs-params">(LinkList L)</span></span>&#123;
    LNode* p = L-&gt;next;
    <span class="hljs-keyword">while</span>(p)&#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, p-&gt;data);
        p = p-&gt;next;
    &#125;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);
&#125;
</code></pre>
<h5 id="顺序表和链表对比"><a class="markdownIt-Anchor" href="#顺序表和链表对比"></a> 顺序表和链表对比</h5>
<p>顺序表</p>
<ul>
<li>表长固定，事先确定</li>
<li>插入删除少，按顺序访问多</li>
</ul>
<p>链表</p>
<ul>
<li>长度可以变化</li>
<li>频繁插入</li>
</ul>
<p>单链表的就地逆置</p>
<pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inverseLList</span><span class="hljs-params">(LinkList &amp;L)</span>
</span>&#123;
    LinkList p, q, temp = <span class="hljs-literal">NULL</span>;
    p = L-&gt;next;
    q = L-&gt;next-&gt;next;
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span> || q == <span class="hljs-literal">NULL</span>)
    &#123;
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">while</span> (q != <span class="hljs-literal">NULL</span>)
    &#123;
        temp = q-&gt;next;
        q-&gt;next = p;
        p = q;
        q = temp;
    &#125;
    L-&gt;next-&gt;next = <span class="hljs-literal">NULL</span>; 
    L-&gt;next = p;
&#125;
</code></pre>
<p>双向链表</p>
<pre class="highlight"><code class="c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">DLNode</span>&#123;
	ElemType data;
	<span class="hljs-keyword">struct</span> <span class="hljs-title class_">DLNode</span> *prior, *next;
&#125;DLNode, *DLinkList;

<span class="hljs-comment">// 插入</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertDLinkList</span><span class="hljs-params">(DLinkList p, Elemtype e)</span></span>&#123;
    DLNode* s = <span class="hljs-keyword">new</span> DLNode;
    s-&gt;data = e;
    s-&gt;next = p-&gt;next;
    s-&gt;prior = p;
    p-&gt;next = s;
    s-&gt;next-&gt;prior = s;
&#125;

<span class="hljs-comment">// 删除</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteDLinkList</span><span class="hljs-params">(DLinkList s)</span></span>&#123;
    s-&gt;prior-&gt;next = s-&gt;next;
    s-&gt;next-&gt;prior = s-&gt;prior;
    <span class="hljs-keyword">delete</span> s;
&#125;
</code></pre>
<h3 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h3>
<h4 id="有序表的合并"><a class="markdownIt-Anchor" href="#有序表的合并"></a> 有序表的合并</h4>
<h5 id="顺序表的合并"><a class="markdownIt-Anchor" href="#顺序表的合并"></a> 顺序表的合并</h5>
<pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeSqList</span><span class="hljs-params">(SqList &amp;LA, SqList LB)</span></span>&#123;
    <span class="hljs-type">int</span> la = LA.length, lb = LB.length;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; lb; i ++ )&#123;
        <span class="hljs-type">int</span> has = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; la; j ++ )&#123;
            <span class="hljs-keyword">if</span>(LA.elem[j] == LB.elem[i])&#123;
                has = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">if</span>(has) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">else</span>&#123;
            LA.elem[LA.length] = LB.elem[i];
            LA.length ++ ;
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="链表的合并"><a class="markdownIt-Anchor" href="#链表的合并"></a> 链表的合并</h5>
<pre class="highlight"><code class="c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mergeLinkList</span><span class="hljs-params">(LinkList &amp;LA, LinkList LB)</span>
</span>&#123;
	LinkList p = LA;
	<span class="hljs-keyword">while</span> (p-&gt;next)
	&#123;
		p = p-&gt;next;
	&#125;
	LinkList s = LB-&gt;next;
	<span class="hljs-keyword">while</span> (s)
	&#123;
		LinkList t = LA-&gt;next;
		<span class="hljs-keyword">while</span> (t)
		&#123;
			<span class="hljs-keyword">if</span> (t-&gt;data == s-&gt;data) <span class="hljs-keyword">break</span>;
			t = t-&gt;next;
		&#125;
		<span class="hljs-keyword">if</span> (!t)
		&#123;
			LinkList e = <span class="hljs-keyword">new</span> LNode;
			e-&gt;data = s-&gt;data;
			e-&gt;next = <span class="hljs-literal">NULL</span>;
			p-&gt;next = e;
			p = e;
		&#125;
		s = s-&gt;next;
	&#125;
&#125;
</code></pre>
<h4 id="一元多项式的运算"><a class="markdownIt-Anchor" href="#一元多项式的运算"></a> 一元多项式的运算</h4>
<h5 id="多项式的加法"><a class="markdownIt-Anchor" href="#多项式的加法"></a> 多项式的加法</h5>
<pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PNode</span>
&#123;
    <span class="hljs-type">int</span> coeff;
    <span class="hljs-type">int</span> expn;
    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PNode</span> *next;
&#125; PNode, *Poly;
<span class="hljs-comment">// 根据用户的输入，创建多项式</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createPoly</span><span class="hljs-params">(Poly &amp;P, <span class="hljs-type">int</span> n)</span>
</span>&#123;
    P = <span class="hljs-keyword">new</span> PNode;
    P-&gt;next = <span class="hljs-literal">NULL</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)
    &#123;
        PNode *s = <span class="hljs-keyword">new</span> PNode;
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;s-&gt;coeff, &amp;s-&gt;expn);
        PNode *pre = P;
        PNode *r = P-&gt;next;
        <span class="hljs-keyword">while</span> (r &amp;&amp; r-&gt;expn &lt; s-&gt;expn)
        &#123;
            pre = r;
            r = r-&gt;next;
        &#125;
        s-&gt;next = r;
        pre-&gt;next = s;
    &#125;
&#125;
<span class="hljs-comment">// 根据输出要求，打印多项式</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPoly</span><span class="hljs-params">(Poly P)</span>
</span>&#123;
    <span class="hljs-keyword">if</span> (!P-&gt;next)
    &#123;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0&quot;</span>);
        <span class="hljs-keyword">return</span>;
    &#125;
    PNode *p = P-&gt;next;
    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (p)
    &#123;
        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span> &amp;&amp; p-&gt;expn != <span class="hljs-number">0</span>)
        &#123;
            <span class="hljs-keyword">if</span> (p-&gt;coeff != <span class="hljs-number">0</span>)
            &#123;
                <span class="hljs-keyword">if</span> (p-&gt;coeff == <span class="hljs-number">1</span>)
                    ;
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;coeff == <span class="hljs-number">-1</span>)
                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);
                <span class="hljs-keyword">else</span>
                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, p-&gt;coeff);
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x&quot;</span>);

                <span class="hljs-keyword">if</span> (p-&gt;coeff != <span class="hljs-number">0</span> &amp;&amp; p-&gt;expn &gt;= <span class="hljs-number">2</span>)
                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;^%d&quot;</span>, p-&gt;expn);
                p = p-&gt;next;
                count = <span class="hljs-number">1</span>;
            &#125;
        &#125;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span> &amp;&amp; p-&gt;expn == <span class="hljs-number">0</span>)
        &#123;
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, p-&gt;coeff);
            count = <span class="hljs-number">1</span>;
            p = p-&gt;next;
        &#125;

        <span class="hljs-keyword">else</span>
        &#123;
            <span class="hljs-keyword">if</span> (p-&gt;coeff != <span class="hljs-number">0</span>)
            &#123;
                <span class="hljs-keyword">if</span> (p-&gt;coeff == <span class="hljs-number">1</span>)
                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+&quot;</span>);
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p-&gt;coeff == <span class="hljs-number">-1</span>)
                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);
                <span class="hljs-keyword">else</span>
                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%+d&quot;</span>, p-&gt;coeff);
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x&quot;</span>);
                <span class="hljs-keyword">if</span> (p-&gt;coeff != <span class="hljs-number">0</span> &amp;&amp; p-&gt;expn &gt;= <span class="hljs-number">2</span>)
                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;^%d&quot;</span>, p-&gt;expn);
                p = p-&gt;next;
            &#125;
        &#125;
    &#125;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);
&#125;
<span class="hljs-comment">// 多项式相加，P3=P1+P2</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addPoly</span><span class="hljs-params">(Poly P1, Poly P2, Poly &amp;P3)</span>
</span>&#123;
    PNode *p1 = P1-&gt;next;
    PNode *p2 = P2-&gt;next;
    P3 = <span class="hljs-keyword">new</span> PNode;
    P3-&gt;next = <span class="hljs-literal">NULL</span>;
    PNode *p3 = P3;
    <span class="hljs-keyword">while</span> (p1 &amp;&amp; p2)
    &#123;
        <span class="hljs-keyword">if</span> (p1-&gt;expn == p2-&gt;expn)
        &#123;
            <span class="hljs-type">int</span> sum = p1-&gt;coeff + p2-&gt;coeff;
            <span class="hljs-keyword">if</span> (sum) <span class="hljs-comment">//和不为0</span>
            &#123;
                PNode *r = <span class="hljs-keyword">new</span> PNode;
                r-&gt;coeff = sum;
                r-&gt;expn = p1-&gt;expn;
                r-&gt;next = <span class="hljs-literal">NULL</span>;
                p3-&gt;next = r;
                p3 = p3-&gt;next;
            &#125;
            <span class="hljs-keyword">else</span> <span class="hljs-comment">//和为0</span>
            &#123;
            &#125;
            p1 = p1-&gt;next;
            p2 = p2-&gt;next;
        &#125;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p1-&gt;expn &lt; p2-&gt;expn)
        &#123;
            PNode *r = <span class="hljs-keyword">new</span> PNode;
            r-&gt;expn = p1-&gt;expn;
            r-&gt;coeff = p1-&gt;coeff;
            r-&gt;next = <span class="hljs-literal">NULL</span>;
            p3-&gt;next = r;
            p3 = p3-&gt;next;
            p1 = p1-&gt;next;
        &#125;
        <span class="hljs-keyword">else</span>
        &#123;
            PNode *r = <span class="hljs-keyword">new</span> PNode;
            r-&gt;expn = p2-&gt;expn;
            r-&gt;coeff = p2-&gt;coeff;
            r-&gt;next = <span class="hljs-literal">NULL</span>;
            p3-&gt;next = r;
            p3 = p3-&gt;next;
            p2 = p2-&gt;next;
        &#125;
    &#125;
    p3-&gt;next = p1 ? p1 : p2;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    <span class="hljs-type">int</span> m, n;
    Poly p1, p2, p3;
    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);
    <span class="hljs-built_in">createPoly</span>(p1, m);
    <span class="hljs-built_in">createPoly</span>(p2, n);
    <span class="hljs-built_in">printPoly</span>(p1);
    <span class="hljs-built_in">printPoly</span>(p2);
    <span class="hljs-built_in">addPoly</span>(p1, p2, p3);
    <span class="hljs-built_in">printPoly</span>(p3);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre>
<h5 id="多项式的乘法"><a class="markdownIt-Anchor" href="#多项式的乘法"></a> 多项式的乘法</h5>
<pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span> </span>

<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PNode</span>&#123;
     <span class="hljs-type">int</span> coeff;
     <span class="hljs-type">int</span> expn;
     <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PNode</span> *next;
&#125; PNode, *Poly;

<span class="hljs-comment">// 根据用户的输入，创建多项式</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createPoly</span><span class="hljs-params">(Poly &amp;P, <span class="hljs-type">int</span> n)</span></span>;
<span class="hljs-comment">// 根据输出要求，打印多项式</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPoly</span><span class="hljs-params">(Poly P)</span></span>;
<span class="hljs-comment">// 多项式相乘，P3=P1*P2</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mulPoly</span><span class="hljs-params">(Poly P1, Poly P2, Poly &amp;P3)</span></span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;
	<span class="hljs-type">int</span> m, n;
	Poly p1, p2, p3;
	<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);
	<span class="hljs-built_in">createPoly</span>(p1, m);
	<span class="hljs-built_in">createPoly</span>(p2, n);
	<span class="hljs-built_in">mulPoly</span>(p1, p2, p3);
	<span class="hljs-built_in">printPoly</span>(p1);
	<span class="hljs-built_in">printPoly</span>(p2);
	<span class="hljs-built_in">printPoly</span>(p3);	
	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">createPoly</span><span class="hljs-params">(Poly &amp;P, <span class="hljs-type">int</span> n)</span>
</span>&#123;
	P = <span class="hljs-keyword">new</span> PNode;
	P-&gt;next = <span class="hljs-literal">NULL</span>;
	<span class="hljs-keyword">while</span> (n--)
	&#123;
		Poly s = <span class="hljs-keyword">new</span> PNode;
		<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;s-&gt;coeff, &amp;s-&gt;expn);
		<span class="hljs-keyword">if</span> (s-&gt;coeff == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;
		Poly pre = P, q = P-&gt;next;
		<span class="hljs-keyword">while</span> (q &amp;&amp; q-&gt;expn &lt; s-&gt;expn)
		&#123;
			pre = q;
			q = q-&gt;next;
		&#125;
		s-&gt;next = q;
		pre-&gt;next = s;
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPoly</span><span class="hljs-params">(Poly P)</span>
</span>&#123;
	Poly s = P-&gt;next;
	<span class="hljs-keyword">while</span> (s)
	&#123;
		<span class="hljs-keyword">if</span> (s != P-&gt;next &amp;&amp; s-&gt;coeff &gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+&quot;</span>);
		<span class="hljs-keyword">if</span> (s-&gt;expn == <span class="hljs-number">0</span>)
		&#123;
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, s-&gt;coeff);
		&#125;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s-&gt;expn == <span class="hljs-number">1</span>)
		&#123;
			<span class="hljs-keyword">if</span> (s-&gt;coeff != <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, s-&gt;coeff);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x&quot;</span>);
		&#125;
		<span class="hljs-keyword">else</span>
		&#123;
			<span class="hljs-keyword">if</span> (s-&gt;coeff != <span class="hljs-number">1</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, s-&gt;coeff);
			<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x^%d&quot;</span>, s-&gt;expn);
		&#125;
		s = s-&gt;next;
	&#125;
	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addPoly</span><span class="hljs-params">(Poly P1, Poly P2, Poly &amp;P3)</span>
</span>&#123;
	Poly i = P1-&gt;next, j = P2-&gt;next, k = P3;
	k-&gt;next = <span class="hljs-literal">NULL</span>;
	<span class="hljs-keyword">while</span> (i &amp;&amp; j)
	&#123;
		Poly t = <span class="hljs-keyword">new</span> PNode;
		t-&gt;next = <span class="hljs-literal">NULL</span>;
		<span class="hljs-keyword">if</span> (i-&gt;expn == j-&gt;expn)
		&#123;
			<span class="hljs-keyword">if</span> (i-&gt;coeff + j-&gt;coeff == <span class="hljs-number">0</span>)
			&#123;
				i = i-&gt;next;
				j = j-&gt;next;
				<span class="hljs-keyword">continue</span>;
			&#125;
			t-&gt;coeff = i-&gt;coeff + j-&gt;coeff;
			t-&gt;expn = i-&gt;expn;
			i = i-&gt;next;
			j = j-&gt;next;
		&#125;
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i-&gt;expn &lt; j-&gt;expn)
		&#123;
			t-&gt;coeff = i-&gt;coeff;
			t-&gt;expn = i-&gt;expn;
			i = i-&gt;next;
		&#125;
		<span class="hljs-keyword">else</span>
		&#123;
			t-&gt;coeff = j-&gt;coeff;
			t-&gt;expn = j-&gt;expn;
			j = j-&gt;next;
		&#125;
		k-&gt;next = t;
		k = t;
	&#125;
	<span class="hljs-keyword">while</span> (i)
	&#123;
		Poly t = <span class="hljs-keyword">new</span> PNode;
		t-&gt;coeff = i-&gt;coeff;
		t-&gt;expn = i-&gt;expn;
		t-&gt;next = <span class="hljs-literal">NULL</span>;
		k-&gt;next = t;
		k = t;
		i = i-&gt;next;
	&#125;
	<span class="hljs-keyword">while</span> (j)
	&#123;
		Poly t = <span class="hljs-keyword">new</span> PNode;
		t-&gt;coeff = j-&gt;coeff;
		t-&gt;expn = j-&gt;expn;
		t-&gt;next = <span class="hljs-literal">NULL</span>;
		k-&gt;next = t;
		k = t;
		j = j-&gt;next;
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cal</span><span class="hljs-params">(Poly P1, Poly P2, Poly &amp;P3)</span>
</span>&#123;
	Poly p2 = P2-&gt;next;
	Poly p = P3;
	<span class="hljs-keyword">while</span> (p2)
	&#123;
		Poly t = <span class="hljs-keyword">new</span> PNode;
		t-&gt;expn = P1-&gt;expn + p2-&gt;expn;
		t-&gt;coeff = P1-&gt;coeff * p2-&gt;coeff;
		t-&gt;next = <span class="hljs-literal">NULL</span>;
		p-&gt;next = t;
		p = t;
		p2 = p2-&gt;next;
	&#125;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mulPoly</span><span class="hljs-params">(Poly P1, Poly P2, Poly &amp;P3)</span>
</span>&#123;
	P3 = <span class="hljs-keyword">new</span> PNode;
	P3-&gt;next = <span class="hljs-literal">NULL</span>;
	Poly p1 = P1-&gt;next;
	<span class="hljs-keyword">while</span> (p1)
	&#123;
		Poly t = <span class="hljs-keyword">new</span> PNode;
		t-&gt;next = <span class="hljs-literal">NULL</span>;
		<span class="hljs-built_in">cal</span>(p1, P2, t);
		<span class="hljs-built_in">addPoly</span>(t, P3, P3);
		p1 = p1-&gt;next;
	&#125;
&#125;
</code></pre>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2022/09/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><i class="fa fa-arrow-left" aria-hidden="true"></i></a><a class="next" href="/2022/11/17/SQL/"><i class="fa fa-arrow-right" aria-hidden="true"></i></a></div><ins class="adsbygoogle adsense-bottom" style="display:block" data-ad-client="ca-pub-6188640546219653" data-ad-slot="6129396565" data-ad-format="auto"></ins><div class="fb-comments-area"><div class="fb-comments" data-href="http://example.com/2022/10/24/线性表/" data-width="700" data-numposts="5"></div></div><div class="copyright"><p>© 2012 - 2023 <a href="https://github.com/stunstunstun" target="_blank">Minhyeok Jung</a>. Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/stunstunstun/hexo-theme-chiangmai" target="_blank">hexo-theme-chiangmai</a>.</p></div></footer></div><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({});</script><script>window.fbAsyncInit=function(){FB.init({appId:"1258629384258634",cookie:!0,xfbml:!0,version:"v2.8"}),FB.AppEvents.logPageView()},function(e,n,t){var o,c=e.getElementsByTagName(n)[0];e.getElementById(t)||((o=e.createElement(n)).id=t,o.src="//connect.facebook.net/en_US/sdk.js",c.parentNode.insertBefore(o,c))}(document,"script","facebook-jssdk");</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create','UA-97419941-1','auto');ga('send','pageview');</script></body></html>