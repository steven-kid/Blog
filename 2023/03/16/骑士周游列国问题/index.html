<!DOCTYPE html><html lang="zh-cn" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>骑士周游列国(A*解法) · Steven's blog</title><meta name="description" content=""><meta name="og:title" content="骑士周游列国(A*解法)"><meta name="og:type" content="website"><meta name="og:url" content="http://example.com/2023/03/16/骑士周游列国问题/"><meta name="og:image" content="http://image.toast.com/aaaaahq/hola_cover.JPG"><meta name="og:description" content=""><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/chiangmai.css"><meta name="steem:author" content="@stunstunstun"><meta name="fb:app_id" content="1258629384258634"><link rel="search" type="application/opensearchdescription+xml" href="http://example.com/atom.xml" title="Steven's blog"><meta name="generator" content="Hexo 6.1.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="Steven's blog" type="application/atom+xml">
</head><body class="post"><div id="fb-root"></div><div class="wrap"><header><nav class="navi-post"><a class="navi-post-back" href="javascript:history.back()"><i class="fa fa-arrow-left" aria-hidden="true"></i></a><a class="navi-post-home" href="/"><i class="fa fa-home" aria-hidden="true"></i></a></nav></header><main class="post"><div class="post"><article class="post-block"><h1 class="post-title">骑士周游列国(A*解法)</h1><div class="post-info"><div class="post-info-profile"><a href="https://github.com/stunstunstun" target="_blank"><img src="/image/profile.jpg"></a></div><div class="post-info-details"><div class="post-categories"><a href="/categories/%E6%8A%80%E6%9C%AF" target="_self"><span>技术</span></a></div><div class="post-date">2023年3月16日</div></div></div><div class="post-share"><div class="fb-like" data-href="http://example.com/2023/03/16/骑士周游列国问题/" data-layout="button_count" data-action="like" data-size="small" data-show-faces="true" data-share="false">                 </div><div class="fb-share-button" data-href="http://example.com/2023/03/16/骑士周游列国问题/" data-layout="button" data-size="small" data-mobile-iframe="true"></div><div class="fb-follow" data-href="https://www.facebook.com/holaxprogramming/" data-layout="button_count" data-size="small" data-show-faces="true"></div></div><div class="post-content"><h1 id="骑士周游列国问题"><a class="markdownIt-Anchor" href="#骑士周游列国问题"></a> 骑士周游列国问题</h1>
<h4 id="题目背景"><a class="markdownIt-Anchor" href="#题目背景"></a> 题目背景</h4>
<p>国际象棋棋盘由<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">8 \times 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>共<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn></mrow><annotation encoding="application/x-tex">64</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span></span></span></span>个黑白相间的块组成，每个棋子占据一个块。在国际象棋中，马的行走方式与中国象棋类似，即可以向以自身为角点的“日”字形的对角线移动。</p>
<p>经检验，当棋盘上有且仅有一个马时，无论其初始位置如何，均可沿规则允许的方式不重不漏地走遍棋盘的全部位置。</p>
<h4 id="题目描述"><a class="markdownIt-Anchor" href="#题目描述"></a> 题目描述</h4>
<p>已知棋盘上只有一个马，其初始位置为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>r</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>l</mi><mo>&lt;</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">0 \leq row,col &lt; 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>，求解一条满足上述要求的路径。</p>
<h4 id="输入格式"><a class="markdownIt-Anchor" href="#输入格式"></a> 输入格式</h4>
<p>每个数据一行，每行两个数字，分别代表初始行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>o</mi><mi>w</mi></mrow><annotation encoding="application/x-tex">row</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span></span>和初始列<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi></mrow><annotation encoding="application/x-tex">col</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span>。数字间以空格隔开，行末尾为 <span class='katex-error' title='ParseError: KaTeX parse error: Undefined control sequence: \n at position 1: \̲n̲'>\n</span></p>
<h4 id="输出格式"><a class="markdownIt-Anchor" href="#输出格式"></a> 输出格式</h4>
<p>输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo>×</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">8 \times 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">8</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span>的矩阵<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>M</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi></mrow></msub></mrow><annotation encoding="application/x-tex">M_{i,j}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>代表沿此路径行走时，到达方格<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>的步数（初始位置步数记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>，以此类推）。数字间以空格隔开（行末无空格），每行以\n 结尾（含最后一行）。</p>
<p>注意：满足题意的路径可能不只有一种，输出时只输出一种结果。</p>
<h4 id="样例-1"><a class="markdownIt-Anchor" href="#样例-1"></a> 样例 #1</h4>
<h5 id="样例输入-1"><a class="markdownIt-Anchor" href="#样例输入-1"></a> 样例输入 #1</h5>
<pre class="highlight"><code class="">2 6
</code></pre>
<h5 id="样例输出-1"><a class="markdownIt-Anchor" href="#样例输出-1"></a> 样例输出 #1</h5>
<pre class="highlight"><code class="">33 30 57 20 55 18 5 2
58 21 32 29 6 3 54 17
31 34 23 56 19 52 1 4
22 59 28 35 64 7 16 53
45 24 63 8 43 36 51 14
60 9 44 27 48 15 42 39
25 46 11 62 37 40 13 50
10 61 26 47 12 49 38 41
</code></pre>
<h4 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 提示</h4>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mi>r</mi><mi>o</mi><mi>w</mi><mo separator="true">,</mo><mi>c</mi><mi>o</mi><mi>l</mi><mo>&lt;</mo><mn>8</mn></mrow><annotation encoding="application/x-tex">0 &lt; row, col &lt; 8</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68354em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">8</span></span></span></span></p>
<h3 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析"></a> 问题分析</h3>
<h4 id="解法-i-普通的搜索回溯"><a class="markdownIt-Anchor" href="#解法-i-普通的搜索回溯"></a> 解法 Ⅰ 普通的搜索回溯</h4>
<p>首先对于骑士周游列国这一问题，我们很难找到一个多项式复杂度的算法，所以我们考虑搜索之后再进行剪枝的做法。</p>
<p>对于搜索，我们可以直接使用深度优先搜索的方式，在每一次记录当前所在的点坐标以及当前的步数，通过 x，y 的变化代表位置的转移，注意回溯即可</p>
<p>之后我们为了简化代码，采用定义偏移数组的方式进行位置的变化，数组表达如下</p>
<p>int dx[] = {1, 2, -1, -2, 2, 1, -1, -2};<br />
int dy[] = {2, 1, 2, 1, -1, -2, -2, -1};</p>
<p>这八位的数组分别代表八个方向偏移的坐标，用来 x，y 来表示当前点的位置，用 nowx，nowy 代表</p>
<p>每次到达对应的 nowx，nowy 之后，我们再对这些点进行检测，如果超出棋盘范围，就舍去。</p>
<p>按照这样的方式，我们肯定能够在遍历所有可能性之后确定这条路线，代码如下</p>
<pre class="highlight"><code class="c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> endl (<span class="hljs-string">&#x27;\n&#x27;</span>)</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;
<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;
<span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>&#125;;
<span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>&#125;;
<span class="hljs-comment">// const double eps = 1e-6;</span>

<span class="hljs-type">int</span> n, m, k;
<span class="hljs-type">int</span> a[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">In</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> <span class="hljs-comment">// 判断是否在棋盘内</span>
</span>&#123;
    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= <span class="hljs-number">8</span> || y &lt; <span class="hljs-number">0</span> || y &gt;= <span class="hljs-number">8</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> step)</span> <span class="hljs-comment">// 暴力搜索</span>
</span>&#123;
    <span class="hljs-keyword">if</span> (step == <span class="hljs-number">64</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; v;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)
    &#123;
        <span class="hljs-type">int</span> nowx = x + dx[i];
        <span class="hljs-type">int</span> nowy = y + dy[i];
        <span class="hljs-keyword">if</span> ((!<span class="hljs-built_in">In</span>(nowx, nowy)) || a[nowx][nowy] != <span class="hljs-number">0</span>)
            <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">else</span>&#123;
            a[nowx][nowy] = step + <span class="hljs-number">1</span>;
            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(nowx, nowy, step + <span class="hljs-number">1</span>))
				<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
            a[nowx][nowy] = <span class="hljs-number">0</span>;
        &#125;

    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span>
</span>&#123;
    <span class="hljs-type">int</span> x, y;
    cin &gt;&gt; x &gt;&gt; y;
    a[x][y] = <span class="hljs-number">1</span>;
    <span class="hljs-built_in">dfs</span>(x, y, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)
    &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">7</span>; j++)
        &#123;
            cout &lt;&lt; a[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
        &#125;
        cout &lt;&lt; a[i][<span class="hljs-number">7</span>] &lt;&lt; endl;
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);
    <span class="hljs-built_in">solve</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre>
<p>但是此时我们的复杂度还是比较高的，经测试此时这样的算法只能完成 6*6 的棋盘搜索，对于 8*8 的表格是无法在 1s 之内完成的</p>
<p>我们可以考虑进行优化</p>
<h4 id="解法-ii-搜索剪枝优化"><a class="markdownIt-Anchor" href="#解法-ii-搜索剪枝优化"></a> 解法 Ⅱ 搜索+剪枝优化</h4>
<p>留意到，在搜索的过程之中，下一步前往的点之间是存在差异的，</p>
<p>例如有些点到达后再能够往后走的路径并不多，即到达后的选择较少，优先到访这样的点其实是更优的选择</p>
<p><strong>为什么呢？</strong></p>
<p>对于按顺序来访问的情况，我们可以认为每个格子之后访问的节点数量都差不多，假设每次走到节点的子节点有 3~4 个，那么整体的搜索路径大概是这样的三叉树或者四叉树（仅仅画出部分以示意，因为不同节点的子节点可能不同，最终结果并不是一颗满三叉树）</p>
<p><img src="https://s2.loli.net/2023/04/06/fMyQrB6wWaqg18z.png" alt="" /></p>
<p>但是如果我们加入偏好，类似于启发式搜索中的估价函数，给这些节点都加上对应的权重，然后优先到访权重小的，假设此时每个节点只剩 1~2 个子节点，情况就大概是二叉树如下所示（仅仅画出部分，右侧其实还有很多多叉的节点，但是其实那些节点是不会被访问到的），对应的量级就下降了很多。</p>
<p><img src="https://s2.loli.net/2023/04/06/W9fRqICLzg4BwuD.png" alt="" /></p>
<p>实际上，如果我们带上偏好的进行搜索，我们就能够节省进入死胡同之后退出来的成本，假设真的走入了一条没有结果的路，那样我们付出的成本也不算太高，因而能够优化整体的时间</p>
<p>我们这一优化的缺点在于，如果完成全部搜索来找到所有可能的路径，那么无论如何都要将所有的可能搜索完成。无论是用类似二叉树的情况或者是三叉树的情况搜索那么我们的优化就没有意义。</p>
<p><strong>时间复杂度</strong>：由于剪枝之后的复杂度计算变得很复杂，不方便采用 O 表示法来计算，但是时间上大概还是在指数量级</p>
<pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> debug(x) cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> all(x) (x).begin(), (x).end()</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> endl (<span class="hljs-string">&#x27;\n&#x27;</span>)</span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-keyword">typedef</span> pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; PII;
<span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;

<span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>, mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;
<span class="hljs-type">const</span> <span class="hljs-type">int</span> INF = <span class="hljs-number">0x3f3f3f3f</span>;
<span class="hljs-type">int</span> dx[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>&#125;;
<span class="hljs-type">int</span> dy[] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>&#125;;
<span class="hljs-comment">// const double eps = 1e-6;</span>

<span class="hljs-type">int</span> n, m, k;
<span class="hljs-type">int</span> a[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>];

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">In</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>
</span>&#123;
    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span> || x &gt;= <span class="hljs-number">8</span> || y &lt; <span class="hljs-number">0</span> || y &gt;= <span class="hljs-number">8</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_weight</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;
    <span class="hljs-type">int</span> temp_x, temp_y, weight = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)
    &#123;
        temp_x = x + dx[i], temp_y = y + dy[i];
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">In</span>(temp_x, temp_y) &amp;&amp; a[temp_x][temp_y] == <span class="hljs-number">0</span>)
            weight++;
    &#125;
    <span class="hljs-keyword">return</span> weight;
&#125;

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">int</span> step)</span>
</span>&#123;
    <span class="hljs-comment">// cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt;  y &lt;&lt; endl;</span>
    <span class="hljs-keyword">if</span> (step == <span class="hljs-number">64</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    <span class="hljs-comment">// cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;</span>
    vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; v;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)
    &#123;
        <span class="hljs-type">int</span> nowx = x + dx[i];
        <span class="hljs-type">int</span> nowy = y + dy[i];
        <span class="hljs-keyword">if</span> ((!<span class="hljs-built_in">In</span>(nowx, nowy)) || a[nowx][nowy] != <span class="hljs-number">0</span>)
            <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">else</span>&#123;
            v.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-built_in">get_weight</span>(nowx, nowy), nowx, nowy&#125;);
        &#125;

    &#125;
    <span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> temp: v)&#123;
        <span class="hljs-type">int</span> nowx = temp.<span class="hljs-built_in">at</span>(<span class="hljs-number">1</span>), nowy = temp.<span class="hljs-built_in">at</span>(<span class="hljs-number">2</span>);
        <span class="hljs-comment">// cout &lt;&lt; nowx &lt;&lt; &quot; &quot; &lt;&lt; nowy &lt;&lt; endl;</span>
        a[nowx][nowy] = step + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dfs</span>(nowx, nowy, step + <span class="hljs-number">1</span>))
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        a[nowx][nowy] = <span class="hljs-number">0</span>;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span>
</span>&#123;
    <span class="hljs-type">int</span> x, y;
    cin &gt;&gt; x &gt;&gt; y;
    a[x][y] = <span class="hljs-number">1</span>;
    <span class="hljs-built_in">dfs</span>(x, y, <span class="hljs-number">1</span>);
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)
    &#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">7</span>; j++)
        &#123;
            cout &lt;&lt; a[i][j] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;
        &#125;
        cout &lt;&lt; a[i][<span class="hljs-number">7</span>] &lt;&lt; endl;
    &#125;
    <span class="hljs-comment">// checkAns(x, y);</span>
&#125;

<span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);
    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);
    <span class="hljs-built_in">solve</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre>
<p><img src="https://s2.loli.net/2023/04/06/sQh7bK4L6TyE3Hg.png" alt="" /></p>
<h4 id="解法-iii-trick-解法"><a class="markdownIt-Anchor" href="#解法-iii-trick-解法"></a> 解法 Ⅲ Trick 解法</h4>
<p>在此之外，其实还有一种更为快速，但是有一点投机取巧性质的做法</p>
<p>留意到在题目所给的样例中，从 64 是可以走到 1 的，那这样这一条路径就形成了一条环，如下所示</p>
<p>1 -&gt; 2 -&gt; 3 -&gt; … -&gt; 64 -&gt; 1…</p>
<p>那按照这样的方式，这一条环覆盖了棋盘上的所有点，那么如果我们只需要找到一条合法的解，且棋盘的大小不变的情况下，我们可以通过将这条环进行移动来构造可行解。</p>
<p>例如我们现在的起点在样例给的答案中的第 15 个位置上，那么我让到访这个点之前的所有点都回退 15 位，这样子就能把原本的答案改写成为由该位置出发的一个可行解。</p>
<p>为了防止超过 64，只需要进行取模即可</p>
<pre class="highlight"><code class="cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;

<span class="hljs-type">int</span> old[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>] = &lt;!--swig￼<span class="hljs-number">0</span>--&gt;;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;
    <span class="hljs-type">int</span> x, y;
    cin &gt;&gt; x &gt;&gt; y;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i ++)&#123;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j ++)&#123;
            <span class="hljs-type">int</span> temp = (old[i][j] - old[x][y] + <span class="hljs-number">1</span> + <span class="hljs-number">64</span>) % <span class="hljs-number">64</span>;
            cout &lt;&lt; (temp == <span class="hljs-number">0</span> ? <span class="hljs-number">64</span> : temp) &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[j == <span class="hljs-number">7</span>];
        &#125;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;
</code></pre>
<p><img src="https://s2.loli.net/2023/04/06/sQh7bK4L6TyE3Hg.png" alt="" /></p>
<p>**时间复杂度：**这时其实我们只是进行一个数字的转写，总共只需要遍历棋盘一次(64 次)，复杂度在常数级 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2023/03/08/%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/"><i class="fa fa-arrow-left" aria-hidden="true"></i></a><a class="next" href="/2023/04/19/%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%EF%BC%88%E5%88%86%E6%B2%BB%EF%BC%89/"><i class="fa fa-arrow-right" aria-hidden="true"></i></a></div><ins class="adsbygoogle adsense-bottom" style="display:block" data-ad-client="ca-pub-6188640546219653" data-ad-slot="6129396565" data-ad-format="auto"></ins><div class="fb-comments-area"><div class="fb-comments" data-href="http://example.com/2023/03/16/骑士周游列国问题/" data-width="700" data-numposts="5"></div></div><div class="copyright"><p>© 2012 - 2023 <a href="https://github.com/stunstunstun" target="_blank">Minhyeok Jung</a>. Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/stunstunstun/hexo-theme-chiangmai" target="_blank">hexo-theme-chiangmai</a>.</p></div></footer></div><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({});</script><script>window.fbAsyncInit=function(){FB.init({appId:"1258629384258634",cookie:!0,xfbml:!0,version:"v2.8"}),FB.AppEvents.logPageView()},function(e,n,t){var o,c=e.getElementsByTagName(n)[0];e.getElementById(t)||((o=e.createElement(n)).id=t,o.src="//connect.facebook.net/en_US/sdk.js",c.parentNode.insertBefore(o,c))}(document,"script","facebook-jssdk");</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create','UA-97419941-1','auto');ga('send','pageview');</script></body></html>