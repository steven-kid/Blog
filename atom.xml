<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Steven&#39;s blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-06-27T06:26:25.237Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次海边散步</title>
    <link href="http://example.com/2021/06/25/%E6%B5%B7%E8%BE%B9/"/>
    <id>http://example.com/2021/06/25/%E6%B5%B7%E8%BE%B9/</id>
    <published>2021-06-25T09:16:45.000Z</published>
    <updated>2022-06-27T06:26:25.237Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <summary type="html">考完试了，到海边走走</summary>
    
    
    
    <category term="生活" scheme="http://example.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
    <category term="海边" scheme="http://example.com/tags/%E6%B5%B7%E8%BE%B9/"/>
    
  </entry>
  
  <entry>
    <title>最小生成树</title>
    <link href="http://example.com/2021/05/22/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>http://example.com/2021/05/22/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</id>
    <published>2021-05-22T06:16:45.000Z</published>
    <updated>2022-06-27T09:53:45.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最小生成树">最小生成树</h1><hr /><h3 id="prim算法">Prim算法</h3><h4 id="朴素prim算法">朴素Prim算法</h4><h4 id="on2"><span class="math inline">\(O(n^2)\)</span></h4><ol type="1"><li>初始化dist[]数组为0x3f</li><li>枚举之后的每条边（枚举n次） 找到离集合最近的点t用t更新其他点到集合的距离 st[t] = true</li></ol><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N &#x3D;  510, INF &#x3D; 0x3f3f3f3f; int n, m;int dist[N], g[N][N];bool st[N];int prim()&#123;    memset(dist, 0x3f, sizeof(dist));    dist[1] &#x3D; 0;    int res &#x3D; 0;    for(int i &#x3D; 0; i &lt; n; i ++ )  &#x2F;&#x2F;  与朴素版dijkstra一样更新n-1次    &#123;        int t &#x3D; -1;        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ )            if(!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[j] &lt; dist[t]))                t &#x3D; j;        res +&#x3D; dist[t];  &#x2F;&#x2F; 在这里更新结果        st[t] &#x3D; true;        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ )            dist[j] &#x3D; min(dist[j], g[t][j]);  &#x2F;&#x2F; 注意这里的更新方式和dijkstra不一样    &#125;    return res;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(g, 0x3f, sizeof(g));    while(m -- )    &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        g[a][b] &#x3D; g[b][a] &#x3D; min(g[a][b], c);  &#x2F;&#x2F;  存储无向边    &#125;    int t &#x3D; prim();    if(t &gt; INF &#x2F; 2)  printf(&quot;impossible\n&quot;);   &#x2F;&#x2F;  为了保险可以写成t &gt; INF &#x2F; 2    else printf(&quot;%d\n&quot;, t);    return 0;&#125;</code></pre><p>堆优化版(不常用)</p><h3 id="kruskal算法">Kruskal算法</h3><p><span class="math inline">\(O(m\cdot logm)\)</span></p><p>开一个结构体来存储所有的边</p><ol type="1"><li><p>将所有边按边权进行排序 <span class="math inline">\(O(m\cdotlogm)\)</span></p></li><li><p>枚举每条边a，及其权重c <spanclass="math inline">\(O(m)\)</span></p><p>if(a,b不连通)--并查集</p><p>将这条边加入集合中</p></li></ol><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 1e5 + 10, M &#x3D; 1e5 + 10, INF &#x3D; 0x3f3f3f3f;int n, m;int p[N];  &#x2F;&#x2F; 并查集中用到的祖宗节点数组struct Edge&#123;    int a, b, w;    bool operator&lt; (const Edge &amp; x) const&#123;   &#x2F;&#x2F; 重载了小于号方便排序 &#x2F;&#x2F;重载小于号是记得用const加这个结构体的名称        return w &lt; x.w;    &#125;&#125;edge[M];int find(int a)&#123;    if(p[a] !&#x3D; a)  return p[a] &#x3D; find(p[a]);    else return a;&#125;int kruskal()&#123;    sort(edge + 1, edge + 1 + m);    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )  p[i] &#x3D; i;  &#x2F;&#x2F; 初始化并查集!!!!    static int res, cnt;    for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ )    &#123;        int a &#x3D; edge[i].a, b &#x3D; edge[i].b, w &#x3D; edge[i].w;        if(find(a) !&#x3D; find(b))  &#x2F;&#x2F;  如果这两个点不在同一个集合那就把它们加入进来        &#123;            p[find(a)] &#x3D; find(b);            res +&#x3D; w;            cnt ++ ;            if(cnt &#x3D;&#x3D; n - 1) break;  &#x2F;&#x2F; 加了这个优化能稍微快一点         &#125;    &#125;    if(cnt &lt; n - 1)  return INF;    else return res;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ )    &#123;        cin &gt;&gt; edge[i].a &gt;&gt; edge[i].b &gt;&gt; edge[i].w;    &#125;    int x &#x3D; kruskal();    if(x &gt; INF &#x2F; 2)  printf(&quot;impossible\n&quot;);    else printf(&quot;%d&quot;, x);    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">acwing基础课图论笔记</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="最小生成树" scheme="http://example.com/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
    <category term="图论" scheme="http://example.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>数论1</title>
    <link href="http://example.com/2021/05/21/%E6%95%B0%E8%AE%BA1/"/>
    <id>http://example.com/2021/05/21/%E6%95%B0%E8%AE%BA1/</id>
    <published>2021-05-21T09:16:45.000Z</published>
    <updated>2022-06-27T09:35:37.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数论1">数论1</h1><hr /><h3 id="质数">质数</h3><p>定义：针对大于一的整数，如果只包含1和他本身这两个约数，就被称为质数(素数)</p><h4 id="质数的判定试除法">质数的判定：试除法</h4><p><span class="math inline">\(O(\sqrt{n})\)</span></p><p>循环判断时写成<span class="math inline">\(i \le \frac ni\)</span>较好</p><h4 id="分解质因数试除法">分解质因数：试除法</h4><p><span class="math inline">\(O(\sqrt{n})\)</span></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N &#x3D; 1e6 + 5;int num[N];int main()&#123;    int t;    cin &gt;&gt; t;    while (t--)    &#123;        int n;        cin &gt;&gt; n;        memset(num, 0, sizeof(num));        for (int i &#x3D; 2; i &lt;&#x3D; n &#x2F; i; i ++ )        &#123;            &#x2F;&#x2F;  每一个合数都可以用比它小的质数表示            int s &#x3D; 0;            while(n % i &#x3D;&#x3D; 0)   &#x2F;&#x2F;  所以第一次找到的一定是一个质数            &#123;                n &#x2F;&#x3D; i;                s ++ ;            &#125;            if (s) printf(&quot;%d %d\n&quot;, i, s); &#x2F;&#x2F; i一定是质数，s为其出现的次数        &#125;        if (n &gt; 1) printf(&quot;%d 1\n&quot;, n);        &#x2F;&#x2F; 优化利用性质：n中最多只有一个大于sqrt(n)的质因子        &#x2F;&#x2F; 如果还有数那么一定只有这一个未被除过的，直接输出就好        printf(&quot;\n&quot;);    &#125;    return 0;&#125;</code></pre><h4 id="质数筛">质数筛</h4><p><span class="math inline">\(O(n\cdot log(logn))\)</span></p><p>埃式线性筛</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 1e6 + 5;int primes[N];int cnt;bool st[N];int main()&#123;    int n;    cin &gt;&gt; n;    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )    &#123;        if(!st[i]) primes[cnt ++ ] &#x3D; i;                for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j ++ )        &#123;            st[primes[j] * i] &#x3D; true;  &#x2F;&#x2F;  标记该质数的倍数都是合数            if (i % primes[j] &#x3D;&#x3D; 0) break;  &#x2F;&#x2F; prime[j]一定是i的最小质因子        &#125;    &#125;    printf(&quot;%d&quot;, cnt);    return 0;&#125;</code></pre><h3 id="约数">约数</h3><h4 id="求所有约数试除法">求所有约数:试除法</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#pragma GCC diagnostic error &quot;-std&#x3D;c++11&quot; #include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#define debug(x) cout &lt;&lt; #x &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; x &lt;&lt; endl;using namespace std;typedef pair&lt;int, int&gt; PII;typedef long long LL;const int N &#x3D; 1e6 + 5, mod &#x3D; 1e9 + 7;const double esp &#x3D; 1e-6;int main()&#123;    int t;    cin &gt;&gt; t;    vector&lt;int&gt; res;    while (t--) &#123;        int n;        cin &gt;&gt; n;        res.clear();        for (int i &#x3D; 1; i &lt;&#x3D; n &#x2F; i; i ++ )        &#123;            if (n % i &#x3D;&#x3D; 0)            &#123;                res.push_back(i);                if(i !&#x3D; n &#x2F; i)  res.push_back(n &#x2F; i);            &#125;        &#125;        sort(res.begin(), res.end()); &#x2F;&#x2F;  排序保证输出的是有序的        for (auto x:res)        &#123;            printf(&quot;%d &quot;, x);        &#125;        printf(&quot;\n&quot;);    &#125;    return 0;&#125;</code></pre><h4 id="约数个数">约数个数</h4><p>如果 <span class="math inline">\(N=p_{1}^{\alpha_{1}}\cdotp_{2}^{\alpha_{2}} \cdots p_{k}^{\alpha_{k}}\)</span> p为质数</p><p>则约数个数为 <span class="math inline">\((\alpha_{1} + 1)(\alpha_{2}+ 1)\cdots(\alpha_{k} + 1)\)</span> 本质上是利用了乘法原理</p><p>其中所有约数对应了任一个质数可以选择 <spanclass="math inline">\(0\thicksim \alpha\)</span> 次的幂的情况</p><p>int范围内约数个数最多的大约有1500个</p><pre class="language-c++" data-language="c++"><code class="language-c++">#pragma GCC diagnostic error &quot;-std&#x3D;c++11&quot;#include &lt;bits&#x2F;stdc++.h&gt;#define debug(x) cout &lt;&lt; #x &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; x &lt;&lt; endlusing namespace std;typedef pair&lt;int, int&gt; PII;typedef long long LL;const int N &#x3D; 1e6 + 5, mod &#x3D; 1e9 + 7;&#x2F;&#x2F;const double esp &#x3D; 1e-6;int main()&#123;    int t;    cin &gt;&gt; t;    map&lt;int, int&gt; primes;    while (t--) &#123;        int n;        cin &gt;&gt; n;        for(int i &#x3D; 2; i &lt;&#x3D; n &#x2F; i; i ++ )        &#123;            while (n % i &#x3D;&#x3D; 0)             &#123;                n &#x2F;&#x3D; i;                primes[i] ++ ;            &#125;        &#125;        if(n &gt; 1) primes[n] ++ ;    &#125;    LL res &#x3D; 1;    for (auto prime : primes)  res &#x3D; res * (prime.second + 1) % mod;    printf(&quot;%lld\n&quot;, res);    return 0;&#125;</code></pre><h4 id="约数之和">约数之和</h4><p>如果 <span class="math inline">\(N=p_{1}^{\alpha_{1}}\cdotp_{2}^{\alpha_{2}} \cdots p_{k}^{\alpha_{k}}\)</span></p><p>则约数个数为:</p><p><span class="math display">\[(p_{1}^{0} + p_{1}^{1} + \cdots +p_{1}^{\alpha_{1}})\cdot (p_{2}^{0} + p_{2}^{1} + \cdots +p_{2}^{\alpha_{2}})\cdot\cdots \cdot (p_{k}^{0} + p_{k}^{1} + \cdots +p_{k}^{\alpha_{k}})\]</span></p><pre class="language-c++" data-language="c++"><code class="language-c++">#pragma GCC diagnostic error &quot;-std&#x3D;c++11&quot;#include &lt;bits&#x2F;stdc++.h&gt;#define debug(x) cout &lt;&lt; #x &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; x &lt;&lt; endlusing namespace std;typedef pair&lt;int, int&gt; PII;typedef long long LL;const int N &#x3D; 1e6 + 5, mod &#x3D; 1e9 + 7;&#x2F;&#x2F;const double esp &#x3D; 1e-6;map&lt;int, int&gt; primes;int main()&#123;    int t;    cin &gt;&gt; t;    while (t -- )    &#123;        int n;        cin &gt;&gt; n;        for (int i &#x3D; 2; i &lt;&#x3D; n &#x2F; i; i ++)        &#123;            while (n % i &#x3D;&#x3D; 0)            &#123;                primes[i] ++ ;                n &#x2F;&#x3D; i;            &#125;        &#125;        if (n &gt; 1)  primes[n] ++ ;    &#125;    LL res &#x3D; 1;    for (auto p : primes)  &#x2F;&#x2F; 按照求和的公式进行计算    &#123;        LL a &#x3D; p.first, b &#x3D; p.second;        &#x2F;&#x2F;  a是底数，b是指数        LL t &#x3D; 1;        while (b -- ) t &#x3D; (t * a + 1) % mod;        &#x2F;&#x2F;  利用秦九韶算法, 每次乘以加一---复杂度O(n)        res &#x3D; res * t % mod;    &#125;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;</code></pre><h4 id="最大公约数">最大公约数</h4><p>欧几里得算法(辗转相除法)</p><p>时间复杂度：<span class="math inline">\(O(logn)\)</span></p><p>核心原理：<span class="math inline">\(gcd(a, b)=gcd(b,a \%b)\)</span></p><pre class="language-c++" data-language="c++"><code class="language-c++">int gcd(int a, int b)&#123;return b ? gcd(b, a % b) : a;&#125;</code></pre><h3 id="欧拉函数">欧拉函数</h3><p><span class="math inline">\(\varphi(n)\)</span>指<spanclass="math inline">\(1\sim n\)</span>中与<spanclass="math inline">\(n\)</span>互质的数的个数</p><p>当 <span class="math inline">\(N=p_{1}^{\alpha_{1}}\cdotp_{2}^{\alpha_{2}} \cdots p_{k}^{\alpha_{k}}\)</span></p><p>则有</p><p><span class="math display">\[\begin{align}\varphi(n) &amp; = N\cdot(1 - \frac{1}{p_{1}})\cdot (1 -\frac{1}{p_{2}}) \cdots (1 - \frac{1}{p_{k}}) \\&amp; = N\cdot(\frac{p_{1} - 1}{p_{1}})\cdot (\frac{p_{2} - 1}{p_{2}})\cdots (\frac{p_{k} - 1}{p_{k}})\end{align}\]</span></p><p>可利用容斥原理进行证明</p><p>时间复杂度：<span class="math inline">\(O(\sqrt {n})\)</span>由分解质因数决定</p><h4 id="分解法">分解法</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#pragma GCC diagnostic error &quot;-std&#x3D;c++11&quot;#include &lt;bits&#x2F;stdc++.h&gt;#define debug(x) cout &lt;&lt; #x &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; x &lt;&lt; endlusing namespace std;typedef pair&lt;int, int&gt; PII;typedef long long LL;&#x2F;&#x2F;const int N &#x3D; 1e6 + 5, mod &#x3D; 1e9 + 7;&#x2F;&#x2F;const double esp &#x3D; 1e-6;int Eular(int a)&#123;    int res &#x3D; a;    for (int i &#x3D; 2;  i &lt;&#x3D; a &#x2F; i; i ++ )    &#123;        if(a % i &#x3D;&#x3D; 0)        &#123;            res &#x3D; res &#x2F; i * (i - 1);            while (a % i &#x3D;&#x3D; 0) a &#x2F;&#x3D; i;         &#125;    &#125;    if (a &gt; 1)  res &#x3D; res &#x2F; a * (a - 1);    return res;&#125;int main()&#123;    int t;    cin &gt;&gt; t;    while (t -- )    &#123;        int a;        cin &gt;&gt; a;        printf(&quot;%d\n&quot;, Eular(a));    &#125;    return 0;&#125;</code></pre><h4 id="线性筛法">线性筛法</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#pragma GCC diagnostic error &quot;-std&#x3D;c++11&quot;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;typedef pair&lt;int, int&gt; PII;typedef long long LL;const int N &#x3D; 1e6 + 5, mod &#x3D; 1e9 + 7;int primes[N], cnt;int phi[N];bool st[N];void get_eulers(int n)&#123;    phi[1] &#x3D; 1;    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )    &#123;        if (!st[i])        &#123;            primes[cnt ++ ] &#x3D; i;            phi[i] &#x3D; i - 1;  &#x2F;&#x2F;  i是质数        &#125;        for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j ++ )        &#123;            st[primes[j] * i] &#x3D; true;            if (i % primes[j] &#x3D;&#x3D; 0)            &#123;                phi[primes[j] * i] &#x3D; phi[i] * primes[j];                break;            &#125;            phi[primes[j] * i] &#x3D; phi[i] * (primes[j] - 1);        &#125;    &#125;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    get_eulers(n);    LL res &#x3D; 0;    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )        res +&#x3D; phi[i];    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;</code></pre><h3 id="快速幂">快速幂</h3><h4 id="模板">模板</h4><p>求<span class="math inline">\(a^{k}\%p\)</span></p><p>优化原理：将指数用二进制预处理</p><p>复杂度<span class="math inline">\(O(logn)\)</span></p><pre class="language-c++" data-language="c++"><code class="language-c++">LL q_pow(LL a, LL k, LL mod)&#123;    LL res &#x3D; 1;    while (k)    &#123;        if (k&amp;1)  res &#x3D; res * a % mod;        a &#x3D; a * a % mod;        k &gt;&gt;&#x3D; 1;    &#125;    return res;&#125;</code></pre><h4 id="快速幂求乘法逆元">快速幂求乘法逆元</h4><p>乘法逆元的定义</p><blockquote><p>若整数 <span class="math inline">\(b\)</span>，<spanclass="math inline">\(m\)</span>互质，并且对于任意的整数 <spanclass="math inline">\(a\)</span>，如果满足 <spanclass="math inline">\(b|a\)</span>，则存在一个整数 <spanclass="math inline">\(x\)</span>，使得<spanclass="math inline">\(a/b≡a×x(modm)\)</span>，则称 <spanclass="math inline">\(x\)</span> 为 <spanclass="math inline">\(b\)</span> 的模 <spanclass="math inline">\(m\)</span> 乘法逆元，记为 <spanclass="math inline">\(b^{−1}(modm)\)</span> <spanclass="math inline">\(b\)</span> 存在乘法逆元的充要条件是 <spanclass="math inline">\(b\)</span> 与模数 <spanclass="math inline">\(m\)</span> 互质。当模数 <spanclass="math inline">\(m\)</span> 为质数时，<spanclass="math inline">\(b^{m−2}\)</span> 即为 <spanclass="math inline">\(b\)</span> 的乘法逆元</p></blockquote><p>那么等价于求<span class="math inline">\(b^{m−2}\)</span></p><p>用快速幂<code>q_pow(b, m - 2, m)</code>即可</p><p>注意：当 <span class="math inline">\(b\%p==0\)</span> 时无解</p><h3 id="扩展欧几里得算法">扩展欧几里得算法</h3><h4 id="裴蜀定理">裴蜀定理</h4><blockquote><p>对于任意正整数<spanclass="math inline">\(a,b\)</span>，一定存在非零整数<spanclass="math inline">\(x,y\)</span>，使得 <spanclass="math inline">\(ax+by=gcd(a,b)\)</span></p></blockquote><p>请求出一组 <span class="math inline">\(x, y\)</span> 满足 <spanclass="math inline">\(ax + by = gcd(a, b)\)</span></p><pre class="language-c++" data-language="c++"><code class="language-c++">int exgcd(int a, int b, int &amp;x, int &amp;y)&#123;    if (!b)    &#123;        x &#x3D; 1, y &#x3D; 0;        return a;    &#125;    int d &#x3D; exgcd(b, a % b, y, x);    y -&#x3D; a &#x2F; b * x;    return d;&#125;</code></pre><h4 id="解线性同余方程组">解线性同余方程组</h4><p><span class="math inline">\(a_i×x_i≡b_i(mod\ m_i)\)</span></p><p>求出一个满足上式的<span class="math inline">\(x_i\)</span></p><p>上式等价于<span class="math inline">\(a∗x+m∗y=b\)</span></p><pre class="language-c++" data-language="c++"><code class="language-c++">#pragma GCC diagnostic error &quot;-std&#x3D;c++11&quot;#include &lt;bits&#x2F;stdc++.h&gt;#define debug(x) cout &lt;&lt; #x &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; x &lt;&lt; endlusing namespace std;typedef pair&lt;int, int&gt; PII;typedef long long LL;&#x2F;&#x2F;const int N &#x3D; 1e6 + 5, mod &#x3D; 1e9 + 7;&#x2F;&#x2F;const double esp &#x3D; 1e-6;int exgcd(int a, int b, int &amp;x, int &amp;y)&#123;    if(!b)    &#123;        x &#x3D; 1, y &#x3D; 0;        return a;    &#125;        int d &#x3D; exgcd(b, a % b, y, x);    y -&#x3D; a &#x2F; b * x;    return d;&#125;int main()&#123;    int t;    cin &gt;&gt; t;    while (t--)    &#123;        int a, b, m, x, y;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; m;        int d &#x3D; exgcd(a, m, x, y);        if(b % d) printf(&quot;impossible\n&quot;);        else        &#123;            x &#x3D; (LL)x * b &#x2F; d % m;            cout &lt;&lt; x &lt;&lt; endl;        &#125;    &#125;    return 0;&#125;</code></pre><h4 id="求逆元">求逆元</h4><p>逆元<span class="math inline">\(x\)</span>为满足<spanclass="math inline">\(a*x≡1(mod\ p)\)</span></p><p>等价于$a * x + k * p = 1 $</p><pre class="language-c++" data-language="c++"><code class="language-c++">#pragma GCC diagnostic error &quot;-std&#x3D;c++11&quot;#include &lt;bits&#x2F;stdc++.h&gt;#define debug(x) cout &lt;&lt; #x &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; x &lt;&lt; endlusing namespace std;typedef pair&lt;int, int&gt; PII;typedef long long LL;&#x2F;&#x2F;const int N &#x3D; 1e6 + 5, mod &#x3D; 1e9 + 7;&#x2F;&#x2F;const double esp &#x3D; 1e-6;LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y)&#123;    if(!b)    &#123;        x &#x3D; 1, y &#x3D; 0;        return a;    &#125;        int d &#x3D; exgcd(b, a % b, y, x);    y -&#x3D; a &#x2F; b * x;    return d;&#125;int main()&#123;    LL t;    cin &gt;&gt; t;    while (t--)    &#123;        LL a, p, x, y;        cin &gt;&gt; a &gt;&gt; p;        LL d &#x3D; exgcd(a, p, x, y);        if(d !&#x3D; 1) printf(&quot;impossible\n&quot;);        else        &#123;            cout &lt;&lt; (x + p) % p &lt;&lt; endl; &#x2F;&#x2F; 防止出现负数        &#125;    &#125;    return 0;&#125;</code></pre><h3 id="线性求逆元">线性求逆元</h3><p>通过递推式来求</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 3e6 + 5;typedef long long LL;LL inv[N];int main()&#123;    LL n, mod;    cin &gt;&gt; n &gt;&gt; mod;    inv[1] &#x3D; 1;    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )        inv[i] &#x3D; (mod - mod &#x2F; i) * inv[mod % i] % mod;    for (int i &#x3D; 1; i &lt;&#x3D; n; i ++ )        printf(&quot;%ld\n&quot;, inv[i]);    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">acwing基础课数论笔记</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数论" scheme="http://example.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>数论2</title>
    <link href="http://example.com/2021/05/21/%E6%95%B0%E8%AE%BA2/"/>
    <id>http://example.com/2021/05/21/%E6%95%B0%E8%AE%BA2/</id>
    <published>2021-05-21T09:16:45.000Z</published>
    <updated>2022-06-27T09:35:28.333Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数论2">数论2</h2><hr /><h3 id="中国剩余定理">中国剩余定理</h3><p><span class="math display">\[\left\{\begin{array}{l}x \equiv a_{1}\left(\bmod m_{1}\right) \\x \equiv a_{2}\left(\bmod m_{2}\right) \\\cdots \\x \equiv a_{n}\left(\bmod m_{n}\right)\end{array}\right.\]</span></p><p>则求 <span class="math inline">\(N=\prod_{i=1}^{n} m_{i}\)</span></p><p>得到这个数为</p><p><span class="math display">\[x \equiv \sum_{i=1}^{n} a_{i} \times \frac{N}{m_{i}}\times\left[\left(\frac{N}{m_{i}}\right)^{-1}\right]_{m_{i}} \quad(\bmodN)\]</span></p><p>c++解法</p><pre class="language-C++" data-language="C++"><code class="language-C++">#pragma GCC diagnostic error &quot;-std&#x3D;c++11&quot;#include &lt;bits&#x2F;stdc++.h&gt;#define debug(x) cout &lt;&lt; #x &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; x &lt;&lt; endlusing namespace std;typedef pair&lt;int, int&gt; PII;typedef long long LL;const int N &#x3D; 1e6 + 5;&#x2F;&#x2F;const double eps &#x3D; 1e-6;&#x2F;&#x2F;int dx[] &#x3D; &#123;1, 0, -1, 0&#125;, dy[] &#x3D; &#123;0, -1, 0, 1&#125;;&#x2F;&#x2F; int dx[8] &#x3D; &#123;-1, -1, -1, 0, 1, 1, 1, 0&#125;;&#x2F;&#x2F; int dy[8] &#x3D; &#123;-1, 0, 1, 1, 1, 0, -1, -1&#125;;LL exgcd(LL a, LL b, LL &amp;x, LL &amp;y)&#123;    if (b &#x3D;&#x3D; 0)    &#123;        x &#x3D; 1, y &#x3D; 0;        return a;    &#125;    LL  d &#x3D; exgcd(b, a % b, y, x);    y -&#x3D; a &#x2F; b * x;    return d;&#125;LL inline mod(LL a, LL b)&#123;    return ((a % b) + b) % b;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    LL a1, m1;    cin &gt;&gt; a1 &gt;&gt; m1;    for (int i &#x3D; 1; i &lt; n; i ++ )    &#123;        LL a2, m2, k1, k2;        cin &gt;&gt; a2 &gt;&gt; m2;        LL d &#x3D; exgcd(a1, -a2, k1, k2);        if((m2 - m1) % d)        &#123;            puts(&quot;-1&quot;);            return 0;        &#125;        k1 &#x3D; mod(k1 * (m2 - m1) &#x2F; d, abs(a2 &#x2F; d));        m1 &#x3D; k1 * a1 + m1;        a1 &#x3D; abs(a1 &#x2F; d * a2);    &#125;    cout &lt;&lt; m1;    return 0;&#125;</code></pre><p>python解法</p><pre class="language-python" data-language="python"><code class="language-python">def exgcd(a,b,x,y):    if not b:        x,y &#x3D; 1,0        return a,x,y    d,x,y &#x3D; exgcd(b, a % b, y, x)    temp &#x3D; y    y &#x3D; x - a &#x2F;&#x2F; b * y    x &#x3D; temp    return d,x,yif __name__ &#x3D;&#x3D; &quot;__main__&quot;:    n &#x3D; int(input())    a1,m1 &#x3D; map(int,input().split())    for i in range(n-1):        a2,m2 &#x3D; map(int,input().split())        k1,k2 &#x3D; 0,0        d,k1,k2 &#x3D; exgcd(a1,a2,k1,k2)        if (m2-m1) % d:            print(-1)            exit()        k1 *&#x3D; (m2-m1) &#x2F;&#x2F; d        t &#x3D; a2 &#x2F;&#x2F; d        k1 &#x3D; k1 % t        m1 &#x3D; a1 * k1 + m1        a1 &#x3D; abs(a1 &#x2F;&#x2F; d * a2)    print(m1 % a1)</code></pre><h3 id="求组合数">求组合数</h3><h4 id="求-cb_a递推">Ⅰ求 <spanclass="math inline">\(C^b_a\)</span>(递推)</h4><p>a, b范围是2000，询问<span class="math inline">\(10^5\)</span>次</p><p><span class="math inline">\(C^b_a = C^b_{a - 1} + C^{b - 1}_{a -1}\)</span></p><p>通过递推进行处理</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N &#x3D; 2010, mod &#x3D; 1e9 + 7;int c[N][N];void init()&#123;for(int i &#x3D; 0; i &lt; N; i ++ )&#123;for(int j &#x3D; 0; j &lt;&#x3D; i; j ++ )&#123;if(!j)  c[i][j] &#x3D; 1;else c[i][j] &#x3D; (c[i - 1][j] + c[i - 1][j - 1]) % mod;&#125;&#125;&#125;int main()&#123;    init();    int n;    scanf(&quot;%d&quot;, &amp;n);    while(n -- )    &#123;        int a, b;        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        printf(&quot;%d\n&quot;, c[a][b]);    &#125;    return 0;&#125;</code></pre><h4 id="求-cb_a-预处理逆元">Ⅱ求 <spanclass="math inline">\(C^b_a\)</span> (预处理逆元)</h4><p>a, b范围是 <span class="math inline">\(10^5\)</span>，询问<spanclass="math inline">\(10^4\)</span>次</p><p>预处理出来阶乘和阶乘的逆元，利用该公式进行计算即可</p><p><span class="math inline">\(C^b_a = \frac{a!}{b!(a - b)!}=a!*b!^{-1}*(a - b)!^{-1}\)</span></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int N &#x3D; 1e5 + 10, mod &#x3D; 1e9 + 7;typedef long long LL;int fact[N], infact[N];  &#x2F;&#x2F;  预处理的阶乘及逆元int q_pow(int a, int k, int mod)&#123;    int res &#x3D; 1;    while(k)    &#123;        if(k&amp;1)  res &#x3D; (LL)res * a % mod;        a &#x3D; (LL)a * a % mod;        k &gt;&gt;&#x3D; 1;    &#125;    return res;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    fact[0] &#x3D; infact[0] &#x3D; 1;    for(int i &#x3D; 1; i &lt;&#x3D; N; i ++ )    &#123;        fact[i] &#x3D; (LL) fact[i - 1] * i % mod;        infact[i] &#x3D; (LL)infact[i - 1] * q_pow(i, mod - 2, mod) % mod;    &#125;    while (n -- )    &#123;        int a, b;        cin &gt;&gt; a &gt;&gt; b;        cout &lt;&lt; (LL)fact[a] * infact[b] % mod * infact[a - b] % mod &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre><h4 id="求-cb_a-lucas定理">Ⅲ 求 <spanclass="math inline">\(C^b_a\)</span> (Lucas定理)</h4><p>a, b范围是 <span class="math inline">\(10^{18}\)</span>，询问<spanclass="math inline">\(20\)</span>次</p><p>利用Lucas定理 <span class="math display">\[\left(\begin{array}{c}n \\m\end{array}\right) \bmod p=\left(\begin{array}{c}\lfloor n / p\rfloor \\\lfloor m / p\rfloor\end{array}\right) \cdot\left(\begin{array}{c}n \bmod p \\m \bmod p\end{array}\right) \bmod p\]</span> Lucas 定理用于求解大组合数取模的问题，其中模数必须为素数</p><p>其中<span class="math inline">\(C_{a}^{b}\)</span>的求法推导如下<span class="math display">\[\begin{aligned}C_{a}^{b} &amp;= \frac{a !}{(a-b) ! * b !}\\&amp;=\frac{a *(a-1) *(a-2) * \ldots *(a-b+1) *(a-b) * \ldots * 1}{(a-b)*(a-b-1) * \ldots * 1 * b !} \\&amp;=\frac{a *(a-1) *(a-2) * \ldots(a-b+1)}{b !}\end{aligned}\]</span></p><pre class="language-c++" data-language="c++"><code class="language-c++">#pragma GCC diagnostic error &quot;-std&#x3D;c++11&quot;#include &lt;bits&#x2F;stdc++.h&gt;#define debug(x) cout &lt;&lt; #x &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; x &lt;&lt; endlusing namespace std;typedef pair&lt;int, int&gt; PII;typedef long long LL;const int N &#x3D; 1e6 + 5, mod &#x3D; 1e9 + 7;&#x2F;&#x2F;const double eps &#x3D; 1e-6;&#x2F;&#x2F;int dx[] &#x3D; &#123;1, 0, -1, 0&#125;, dy[] &#x3D; &#123;0, -1, 0, 1&#125;;&#x2F;&#x2F; int dx[8] &#x3D; &#123;-1, -1, -1, 0, 1, 1, 1, 0&#125;;&#x2F;&#x2F; int dy[8] &#x3D; &#123;-1, 0, 1, 1, 1, 0, -1, -1&#125;;int q_pow(int a, int k, int p)&#123;    int res &#x3D; 1;    while(k)    &#123;        if(k &amp; 1)  res &#x3D; (LL)res * a % p;        a &#x3D; (LL)a * a % p;        k &gt;&gt;&#x3D; 1;    &#125;    return res;&#125;int C(int a, int b, int p)&#123;    if(b &gt; a)  return 0;    int res &#x3D; 1;    for (int i &#x3D; 1, j &#x3D; a; i &lt;&#x3D; b; i ++ ,j -- )    &#123;        res &#x3D; (LL)res * j % p;        res &#x3D; (LL)res * q_pow(i, p - 2, p) % p;    &#125;    return res;&#125;int lucas(LL a, LL b, int p)&#123;    if (a &lt; p &amp;&amp; b &lt; p)  return C(a, b, p);    else return (LL)C(a % p, b % p, p) * lucas(a &#x2F; p, b &#x2F; p, p) % p;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    while(n -- )    &#123;        LL a, b;         int p;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; p;        cout &lt;&lt; lucas(a, b, p) &lt;&lt; endl;    &#125;    return 0;&#125;</code></pre><h4 id="求c_ab高精度">Ⅳ 求<spanclass="math inline">\(C_a^b\)</span>(高精度)</h4><p>a, b的范围是5000，求1次，但是要求计算出来所以要用高精度</p><p>c++版本</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 5010;int primes[N], cnt;int sum[N];bool st[N];void get_primes(int n)&#123;    for (int i &#x3D; 2; i &lt;&#x3D; n; i ++ )    &#123;        if(!st[i])  primes[cnt ++ ] &#x3D; i;        for (int j &#x3D; 0; primes[j] &lt;&#x3D; n &#x2F; i; j ++ )        &#123;            st[primes[j] * i] &#x3D; true;            if(i % primes[j] &#x3D;&#x3D; 0) break;        &#125;    &#125;&#125;int get(int n, int p)&#123;    int res &#x3D; 0;    while (n)&#123;        res +&#x3D; n &#x2F; p;        n &#x2F;&#x3D; p;    &#125;    return res;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b)&#123;    vector&lt;int&gt; c;    int t &#x3D; 0;    for (int i &#x3D; 0; i &lt; a.size(); i ++ )    &#123;        t +&#x3D; a[i] * b;        c.push_back(t % 10);        t &#x2F;&#x3D; 10;    &#125;    while(t)    &#123;        c.push_back(t % 10);        t &#x2F;&#x3D; 10;    &#125;    return c;&#125;int main()&#123;    int a, b;    cin &gt;&gt; a &gt;&gt; b;    get_primes(a);    for (int i &#x3D; 0; i &lt; cnt; i ++ )    &#123;        int p &#x3D; primes[i];        sum[i] &#x3D; get(a, p) - get(a - b, p) - get(b, p);    &#125;        vector&lt;int&gt; res;    res.push_back(1);    for (int i &#x3D; 0; i &lt; cnt; i ++ )        for (int j &#x3D; 0; j &lt; sum[i]; j ++ )            res &#x3D; mul(res, primes[i]);                for (int i &#x3D; res.size() - 1; i &gt;&#x3D; 0; i -- )        printf(&quot;%d&quot;, res[i]);            return 0;&#125;</code></pre><p>python版本</p><p>利用定义，但是跑起来比c++略慢</p><pre class="language-python" data-language="python"><code class="language-python">a, b &#x3D; map(int, input().split())up &#x3D; 1down &#x3D; 1for i in range(a - b + 1, a + 1):    up *&#x3D; ifor i in range(1, b + 1):    down *&#x3D; iprint(up &#x2F;&#x2F; down)</code></pre><h4 id="卡特兰数">卡特兰数</h4><p>求满足条件的01序列</p><p>给定n个1，n个0，求它们能排列成的所有序列中，能够满足任意前缀序列中0的个数都不少于1的个数的序列有多少个</p><p>下图中，表示从<span class="math inline">\((0,0)\)</span>走到<spanclass="math inline">\((n,n)\)</span>的路径，在绿线及以下表示合法，若触碰红线即不合法</p><p>结果： <span class="math display">\[ans = C^{n}_{2n} - C^{n - 1}_{2n} = \frac{C^n_{2n}}{n+1}\]</span> 求组合数和逆元即可，注意除以n+1时也要用逆元</p><figure><imgsrc="https://cdn.acwing.com/media/article/image/2020/02/22/6828_9476d97655-Catalan.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;const int mod &#x3D; 1e9 + 7;LL q_pow(LL a, LL k)&#123;    LL ret &#x3D; 1;    while(k)    &#123;        if(k&amp;1) ret &#x3D; ret * a % mod;        a &#x3D; a * a % mod;        k &gt;&gt;&#x3D; 1;    &#125;    return ret;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    LL ans &#x3D; 1;    &#x2F;&#x2F; z    for(int i &#x3D; 2 * n; i &gt; n; i -- ) ans &#x3D; ans * i % mod;    for(int i &#x3D; n; i &gt; 0; i -- )  ans &#x3D; ans * q_pow(i, mod - 2) % mod;        ans &#x3D; ans * q_pow(n + 1, mod - 2) % mod;        cout &lt;&lt; ans &lt;&lt; endl;    return 0;&#125;</code></pre><h4 id="斯特林数">斯特林数</h4><h4 id="错排问题">错排问题</h4><p>n封信，n个信封，求完全放错的方案数?</p><p>记方案数为f[n],可以递推来求</p><p>f[1] = 0, f[2] = 1</p><p>f[i] = (i-1) * (f[i-1] + f[i-2])</p><p>推导逻辑：</p><p>假设第一封信a占据了b的位置，那么此时b放在哪个信封分两种情况，b放在a位置，或b不放在a位置；</p><ul><li><p>第一类：第一种情况是放在a位置，此时b放在a位置，剩下n-2封信进行错排，方案数是f(n-2)</p></li><li><p>第二类：第二种情况是b没有去a的位置，那么b可能出现在除α之外的任何位置，b有n-2个位置可以去，不能去a,b位置，其余所有元素都有n-2个位置可以去（a，b位置不能去），这种情况下相当于除a之外的其它元素的错排问题，即n-1个元素的错排问题，方案数是f(n-1)</p></li><li><p>加法法则：汇总上述分类计数原理，使用加法法则，计算结果是f(n-1)+f(n-2)</p></li><li><p>乘法法则：对于每一封信都如此，当有n-1封信已经错排时，已经完全错排了</p><p>即f[i] = (i-1) * (f[i - 1] + f[i - 2])</p></li></ul><pre class="language-c++" data-language="c++"><code class="language-c++">#pragma GCC diagnostic error &quot;-std&#x3D;c++11&quot;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;const int N &#x3D; 1e6 + 5, mod &#x3D; 1e9 + 7;LL f[N];int main()&#123;    int n;    cin &gt;&gt; n;    f[1] &#x3D; 0;    f[2] &#x3D; 1;    for (int i &#x3D; 3; i &lt;&#x3D; n; i ++ )        f[i] &#x3D; (i - 1) * (f[i - 1] + f[i - 2]);    cout &lt;&lt; f[n] &lt;&lt; endl;    return 0;&#125;</code></pre><h3 id="高斯消元">高斯消元</h3><h4 id="解线性方程组">解线性方程组</h4><p>高斯消元是一种可以可以将增广矩阵化成阶梯型矩阵的算法</p><p>适用于求解包含n个方程，n个未知数的多元线性方程组</p><p><span class="math display">\[\left\{\begin{array}{llll}a_{11} x_{1}+ &amp; a_{12} x_{2}+\ldots+ &amp; a_{1 n} x_{n}= &amp;b_{1} \\a_{21} x_{1}+ &amp; a_{22} x_{2}+\ldots+ &amp; a_{2 n} x_{n}= &amp;b_{2} \\\vdots &amp; \vdots &amp; \vdots &amp; \vdots \\a_{n 1} x_{1}+ &amp; a_{n 2} x_{2}+\ldots+ &amp; a_{n n} x_{n}= &amp;b_{n}\end{array}\right.\]</span></p><p>算法步骤：</p><ul><li>找到当前列绝对值最大的一行</li><li>将这一行移到最上面</li><li>乘以相应的系数将改行的第一个数变成1</li><li>相减相消让下面所有的行的当前列变成0</li></ul><p><span class="math display">\[\left(\begin{array}{ccccc}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1 n} &amp; b_{1} \\a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2 n} &amp; b_{2} \\\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots \\a_{n 1} &amp; a_{n 2} &amp; \cdots &amp; a_{n n} &amp; b_{n}\end{array}\right) \rightarrow \left(\begin{array}{ccccc}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1 n} &amp; b_{1} \\&amp; a_{2 i} &amp; a_{2(i+1)} &amp; a_{2 n} &amp; b_{2} \\&amp; &amp; \ddots &amp; \vdots &amp; \vdots \\&amp; &amp; &amp; a_{n n} &amp; b_{n}\end{array}\right)\]</span></p><ul><li>最后再把阶梯型矩阵从下到上回代到第一层即可得到方程的解</li></ul><p>复杂度<span class="math inline">\(O(n^3)\)</span></p><pre class="language-c++" data-language="c++"><code class="language-c++">#pragma GCC diagnostic error &quot;-std&#x3D;c++11&quot;#include &lt;bits&#x2F;stdc++.h&gt;#define debug(x) cout &lt;&lt; #x &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; x &lt;&lt; endlusing namespace std;typedef pair&lt;int, int&gt; PII;typedef long long LL;const int N &#x3D; 1e3 + 5, mod &#x3D; 1e9 + 7;const double eps &#x3D; 1e-6;  &#x2F;&#x2F; 用eps来判断是否为0&#x2F;&#x2F;int dx[] &#x3D; &#123;1, 0, -1, 0&#125;, dy[] &#x3D; &#123;0, -1, 0, 1&#125;;int n;double a[N][N];int  gauss()&#123;    int c, r;  &#x2F;&#x2F; c代表列col, r代表行row    for (c &#x3D; 0, r &#x3D; 0; c &lt; n; c++)    &#123;        int t &#x3D; r;          &#x2F;&#x2F;  第一步，找到绝对值最大的数所在的行号        for (int i &#x3D; r; i &lt; n; i ++ )            if (fabs(a[i][c]) &gt; fabs(a[t][c]))                t &#x3D; i;        if (fabs(a[t][c]) &lt; eps)  continue;        &#x2F;&#x2F; 如果绝对值最大的是0，那么这一行全是0        for (int i &#x3D; c; i &lt; n + 1; i ++ )              swap(a[t][i], a[r][i]);          &#x2F;&#x2F; 第二步，把当前这一行换到最上面        for (int i &#x3D; n; i &gt;&#x3D; c; i -- )              a[r][i] &#x2F;&#x3D; a[r][c];          &#x2F;&#x2F; 第三步，把当前这一行的第一个数变成1，方程两边同时除以第一个系数        &#x2F;&#x2F; 必须要从后往前，不然第一个数会直接变为1，然后不修改其他系数        for (int i &#x3D; r + 1; i &lt; n; i ++ )            if (fabs(a[i][c]) &gt; eps)  &#x2F;&#x2F; 非零                for (int j &#x3D; n; j &gt;&#x3D; c; j -- )                    a[i][j] -&#x3D; a[r][j] * a[i][c];                    &#x2F;&#x2F;  第四步，把第r+1行~n行的第c列元素都消除为0                    &#x2F;&#x2F;  用最上面一行和这行做差除去这一行       r ++ ;    &#125;    if (r &lt; n)    &#123;        for (int i &#x3D; r; i &lt; n; i ++ )            if(fabs(a[i][n]) &gt; eps)                return 2;  &#x2F;&#x2F; 无解        return 1;  &#x2F;&#x2F; 无数解    &#125;    for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i -- )        for (int j &#x3D; i + 1; j &lt; n; j ++ )            a[i][n] -&#x3D; a[j][n] * a[i][j];    return 0;&#125;int main()&#123;    cin &gt;&gt; n;    for (int i &#x3D; 0; i &lt; n; i ++ )        for (int j &#x3D; 0; j &lt; n + 1; j ++ )            cin &gt;&gt; a[i][j];    int t &#x3D; gauss();    if (t &#x3D;&#x3D; 0)    &#123;        for (int i &#x3D; 0; i &lt; n; i ++ )        if(fabs(a[i][n]) &lt; eps) puts(&quot;0.00&quot;);        else printf(&quot;%.2lf\n&quot;, a[i][n]);    &#125;    else if (t &#x3D;&#x3D; 1)  puts(&quot;Infinite group solutions&quot;);    else puts(&quot;No solution&quot;);    return 0;&#125;</code></pre><h4 id="高斯消元解异或方程组">高斯消元解异或方程组</h4><p>异或=&gt;不进位加法</p><pre class="language-c++" data-language="c++"><code class="language-c++">#pragma GCC diagnostic error &quot;-std&#x3D;c++11&quot;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;typedef pair&lt;int, int&gt; PII;typedef long long LL;const int N &#x3D; 110, mod &#x3D; 1e9 + 7;int n;int a[N][N];int gauss()&#123;    int c, r;    for (c &#x3D; 0, r &#x3D; 0; c &lt; n; c ++ )    &#123;        int t &#x3D; r;        for (int i &#x3D; r; i &lt; n; i ++ )        &#123;            if(a[i][c])                t &#x3D; i;        &#125;        if (!a[t][c])  continue;        for (int i &#x3D; c; i &lt;&#x3D; n; i ++ )            swap(a[r][i], a[t][i]);        for (int i &#x3D; r + 1; i &lt; n; i ++ )            if(a[i][c])                for (int j &#x3D; n; j &gt;&#x3D; c; j -- )                    a[i][j] ^&#x3D; a[r][j];        r ++ ;    &#125;    if(r &lt; n)    &#123;        for (int i &#x3D; r; i &lt; n; i ++ )            if(a[i][n])                return 2;        return 1;    &#125;    for (int i &#x3D; n - 1; i &gt;&#x3D; 0; i -- )        for (int j &#x3D; i + 1; j &lt; n; j ++ )            a[i][n] ^&#x3D; a[i][j] * a[j][n];    return 0;&#125;int main()&#123;    cin &gt;&gt; n;    for (int i &#x3D; 0; i &lt; n; i ++ )    &#123;        for (int j &#x3D; 0; j &lt; n + 1; j ++ )        &#123;            cin &gt;&gt; a[i][j];        &#125;    &#125;    int t &#x3D; gauss();    if(t &#x3D;&#x3D; 0)    &#123;        for (int i &#x3D; 0; i &lt; n; i ++ )            cout &lt;&lt; a[i][n] &lt;&lt; endl;    &#125;    else if(t &#x3D;&#x3D; 1) puts(&quot;Multiple sets of solutions&quot;);    else puts(&quot;No solution&quot;);    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">acwing基础课数论笔记</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="数学" scheme="http://example.com/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="数论" scheme="http://example.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>最短路算法</title>
    <link href="http://example.com/2021/05/21/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <id>http://example.com/2021/05/21/%E6%9C%80%E7%9F%AD%E8%B7%AF/</id>
    <published>2021-05-21T09:16:45.000Z</published>
    <updated>2022-06-27T09:31:27.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最短路">最短路</h1><hr /><p>声明：n个点，m条边 稠密图用邻接矩阵，稀疏图用邻接表</p><p><img src="https://s2.loli.net/2022/03/24/UQgtY4E9yblsL75.png" /></p><h3 id="dijkstra算法">dijkstra算法</h3><p>不适用于有负权边的情况，复杂度为 <spanclass="math inline">\(O(n^2)\)</span>/<spanclass="math inline">\(O(m\cdot logn)\)</span></p><p>有朴素版本和堆(prioirty queue)优化版本</p><h4 id="朴素版本">朴素版本</h4><pre class="language-c++" data-language="c++"><code class="language-c++">int dijkstra()&#123;    memset(dist, 0x3f, sizeof(dist));    dist[1] &#x3D; 0;    for(int i &#x3D; 1; i &lt; n; i ++ )  &#x2F;&#x2F; 因为第一个点已经计算过了，所以循环n-1次即可    &#123;        int t &#x3D; -1;        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ )            if(!st[j] &amp;&amp; (t &#x3D;&#x3D; -1 || dist[j] &lt; dist[t]))                    t &#x3D; j;        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ )            dist[j] &#x3D; min(dist[j], dist[t] + g[t][j]);         st[t] &#x3D; true;    &#125;    if(dist[n] &#x3D;&#x3D; 0x3f3f3f3f)  return -1;    else return dist[n];&#125;</code></pre><h4 id="堆优化版本">堆优化版本</h4><p>(优化的是找出距离最近的点这一步)</p><pre class="language-c++" data-language="c++"><code class="language-c++">void add(int a, int b, int c)  &#x2F;&#x2F; 邻接表存边&#123;    e[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;int dijkstra()&#123;    memset(dist, 0x3f, sizeof(dist));  &#x2F;&#x2F;  初始化距离为正无穷    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;  &#x2F;&#x2F; 元素种类为PII的小根堆    dist[1] &#x3D; 0;    heap.push(make_pair(0, 1));  &#x2F;&#x2F;  由于小根堆中的pair会默认按第一个元素排序，所以这里将距离存到前面    while(heap.size())    &#123;        auto t &#x3D; heap.top();        heap.pop();        int distance &#x3D; t.first, ver &#x3D; t.second;        if(st[ver]) continue;        st[ver]  &#x3D; true;        for(int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i] )  &#x2F;&#x2F;  注意i初始化ver的头指针h[ver]        &#123;            int j &#x3D; e[i];  &#x2F;&#x2F; 取点            if(distance + w[i] &lt; dist[j])             &#123;                dist[j] &#x3D; distance + w[i];            heap.push(make_pair(dist[j], j));            &#125;       &#125;    &#125;    if(dist[n] &#x3D;&#x3D; 0x3f3f3f3f)  return -1;    else return dist[n];&#125;</code></pre><h4 id="vector存图">vector存图</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;#define debug(x) cout &lt;&lt; #x &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; x &lt;&lt; endl#define xx first#define yy secondusing namespace std;typedef pair&lt;int, int&gt; PII;typedef long long LL;const int N &#x3D; 1e6 + 5, mod &#x3D; 1e9 + 7;&#x2F;&#x2F;const double esp &#x3D; 1e-6;int dist[N];bool st[N];int n, m;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    vector&lt;vector&lt;PII&gt;&gt; g(n);    for(int i &#x3D; 1; i &lt;&#x3D; m; i ++)    &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        a --, b --;        g[a].push_back(&#123;b, c&#125;);    &#125;    auto dijkstra &#x3D; [&amp;]()    &#123;        memset(dist, 0x3f, sizeof dist);        memset(st, false, sizeof st);        priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; q;        dist[0] &#x3D; 0;        q.push(&#123;0, 0&#125;);        while(q.size())        &#123;            auto t &#x3D; q.top();            q.pop();            if(st[t.yy]) continue;            st[t.yy] &#x3D; true;             for(auto [u, v] : g[t.yy])            &#123;                if(dist[u] &gt; t.xx + v)                &#123;                    dist[u] &#x3D; t.xx + v;                    q.push(&#123;dist[u], u&#125;);                &#125;            &#125;        &#125;    &#125;;    dijkstra();    if(dist[n - 1] &#x3D;&#x3D; 0x3f3f3f3f) cout &lt;&lt; &quot;-1&quot;;    else cout &lt;&lt; dist[n - 1] &lt;&lt; &#39;\n&#39;;    return 0;&#125;</code></pre><h4 id="邮递员送信">邮递员送信</h4><p>邮递员去送信然后要求送信后再返回（有向边）</p><p>解法：</p><p>反向建边+跑两次dijkstra 正着走过去的时候用一遍dijkstra。返回时就建个返图跑一遍dijkstra。反图可以把所有结点的编号+n建在原图的体系中。</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N &#x3D; 2e5 + 5;  &#x2F;&#x2F;  数组记得开够int n, m;int h[N], ne[N], w[N], e[N], idx;int dist[N];bool st[N];void add(int a, int b, int c)&#123;    e[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;void dijkstra(int fir)&#123;       memset(dist, 0x3f, sizeof(dist));    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt;heap;    dist[fir] &#x3D; 0;    heap.push(make_pair(0, fir));    while(heap.size())    &#123;        PII t &#x3D; heap.top();        heap.pop();        int distance &#x3D; t.first, ver &#x3D; t.second;        if(st[ver])  continue;        st[ver] &#x3D; true;        for(int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];            if(dist[j] &gt; distance + w[i])            &#123;                dist[j] &#x3D; distance + w[i];                heap.push(make_pair(dist[j], j));            &#125;        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(h, -1, sizeof(h));    while(m -- )    &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c);        add(b + n, a + n, c);  &#x2F;&#x2F;  建一个反图    &#125;    dijkstra(1);    LL res &#x3D; 0;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        res +&#x3D; dist[i];    &#125;    dijkstra(1 + n);  &#x2F;&#x2F;  反向跑一次dijkstra    for(int i &#x3D; 1 + n; i &lt;&#x3D; 2 * n; i ++ )    &#123;        res +&#x3D; dist[i];    &#125;    cout &lt;&lt; res;    return 0;&#125;</code></pre><h4 id="最短路计数">最短路计数</h4><p>增加一个num数组进行计数</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int N &#x3D; 2e6 + 5, mod &#x3D; 100003;int n, m;int h[N], ne[N], w[N], e[N], idx;int dist[N], num[N];bool st[N];void add(int a, int b, int c)&#123;    e[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;void dijkstra()&#123;    memset(dist, 0x3f, sizeof(dist));    dist[1] &#x3D; 0;    num[1] &#x3D; 1;    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt; &gt; heap;    heap.push(make_pair(0, 1));    while(heap.size())    &#123;        PII t &#x3D; heap.top();        heap.pop();        int distance &#x3D; t.first, ver &#x3D; t.second;        if(st[ver]) continue;        st[ver] &#x3D; true;        for(int i &#x3D; h[ver]; i !&#x3D; -1; i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];            if(dist[j] &#x3D;&#x3D; distance + w[i])            &#123;                num[j] &#x3D; (num[j] + num[ver]) % mod;            &#125;            if(dist[j] &gt; distance + w[i])            &#123;                dist[j] &#x3D; distance + w[i];                num[j] &#x3D; num[ver];                heap.push(make_pair(dist[j], j));            &#125;        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(h, -1, sizeof(h));    while(m -- )    &#123;        int a, b;        cin &gt;&gt; a &gt;&gt; b;        if(a &#x3D;&#x3D; b) continue;        add(a, b, 1);        add(b, a, 1);    &#125;    dijkstra();    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        printf(&quot;%d\n&quot;, num[i]);    &#125;    return 0;&#125;</code></pre><h3 id="bellman-ford算法">bellman-ford算法</h3><p>适用于有负权边的情况</p><p><span class="math inline">\(O(n \cdot m)\)</span></p><p>如果有负环，或限制最多走k次时可以用，大多数时候用SPFA完全替代</p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N &#x3D; 510, M &#x3D; 10010;int n, m, k;  &#x2F;&#x2F;  n个点，m条边，走不超过k次struct Edge&#123;    int a, b, c;&#125;edge[M];int dist[N], backup[N];void Bellman_ford()&#123;    memset(dist, 0x3f, sizeof(dist));    dist[1] &#x3D; 0;    for(int i &#x3D; 1; i &lt;&#x3D; k; i ++ )    &#123;        memcpy(backup, dist, sizeof(dist));        for(int j &#x3D; 1; j &lt;&#x3D; m; j ++ )        &#123;            Edge e &#x3D; edge[j];            dist[e.b] &#x3D; min(dist[e.b], backup[e.a] + e.c);        &#125;    &#125;&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    for(int i &#x3D; 1; i &lt;&#x3D; m; i ++ )    &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        edge[i].a &#x3D; a, edge[i].b &#x3D; b, edge[i].c &#x3D; c;    &#125;    Bellman_ford();    if(dist[n] &gt; 0x3f3f3f3f &#x2F; 2)  printf(&quot;impossible\n&quot;);    else printf(&quot;%d\n&quot;, dist[n]);    return 0;&#125;</code></pre><h3 id="spfa算法">SPFA算法</h3><p>利用宽搜BFS进行优化</p><p>适用于有负权边的情况</p><p>如果存在负环则不能用</p><p><span class="math inline">\(O(m)\)</span>，最坏情况<spanclass="math inline">\(O(n\cdot m)\)</span></p><h4 id="朴素版本-1">朴素版本</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N &#x3D; 100010;int n, m;int e[N], w[N], ne[N], h[N], idx;int dist[N];bool st[N];void add(int a, int b, int c)&#123;    e[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;int spfa()&#123;    memset(dist, 0x3f, sizeof(dist));    dist[1] &#x3D; 0;    queue&lt;int&gt; q;    q.push(1);    st[1] &#x3D; true;    while(q.size())    &#123;        int t &#x3D; q.front();        q.pop();        st[t] &#x3D; false;        for(int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])  &#x2F;&#x2F; i &#x3D; h[t]忘记写h了易错！！！        &#123;            int j &#x3D; e[i];            if(dist[j] &gt; dist[t] + w[i])            &#123;                dist[j] &#x3D; dist[t] + w[i];                if(!st[j])                &#123;                    q.push(j);  &#x2F;&#x2F;  记得推进队列之中去                    st[j] &#x3D; true;                &#125;            &#125;        &#125;    &#125;    return dist[n];&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m;    memset(h, -1, sizeof h);    while(m -- )    &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        add(a, b, c);    &#125;    int t &#x3D; spfa();    if(t &#x3D;&#x3D; 0x3f3f3f3f)  printf(&quot;impossible\n&quot;);    else printf(&quot;%d\n&quot;, t);    return 0;&#125;</code></pre><h4 id="spfa判断负环">SPFA判断负环</h4><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N &#x3D; 1e5 + 10;int n, m;int h[N], e[N], ne[N], w[N], idx;int dist[N];int cnt[N];bool st[N];void add(int a, int b, int c)&#123;    e[idx] &#x3D; b, w[idx] &#x3D; c, ne[idx] &#x3D; h[a], h[a] &#x3D; idx ++ ;&#125;bool spfa()&#123;    memset(dist, 0x3f, sizeof(dist));    memset(cnt, 0, sizeof(cnt));    queue &lt;int&gt; q;    dist[1] &#x3D; 0;    &#x2F;&#x2F;  如果题目说存在负环，那么需要循环一次将所有的点都加入队列之中    &#x2F;&#x2F;  如果是求是否存在从1开始的负环，那么只将1加入队列之中就可以了    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        q.push(i);           st[i] &#x3D; true;    &#125;    while(q.size())    &#123;        int t &#x3D; q.front();        q.pop();        st[t] &#x3D; false;        for(int i &#x3D; h[t]; i !&#x3D; -1; i &#x3D; ne[i])        &#123;            int j &#x3D; e[i];            if(dist[j] &gt; dist[t] + w[i])            &#123;                dist[j] &#x3D; dist[t] + w[i];                cnt[j] &#x3D; cnt[t] + 1;                 if(cnt[j] &gt;&#x3D; n)  return true;                if(!st[j])                &#123;                    q.push(j);                     st[j] &#x3D; true;                &#125;            &#125;        &#125;    &#125;    return false;&#125;int main()&#123;    int t;    cin &gt;&gt; t;    while(t -- )    &#123;        memset(h, -1, sizeof(h));        memset(e, 0, sizeof(e));        memset(ne, 0, sizeof(ne));        memset(w, 0, sizeof(w));        memset(st, 0, sizeof(st));        idx &#x3D; 0;        cin &gt;&gt; n &gt;&gt; m;        while(m -- )        &#123;            int a, b, w;            cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;            if(w &gt;&#x3D; 0)            &#123;                add(a, b, w);                add(b, a, w);            &#125;            else  add(a, b, w);         &#125;        if(spfa())  printf(&quot;YES\n&quot;);        else printf(&quot;NO\n&quot;);    &#125;    return 0;&#125;</code></pre><p>用cnt[]数组进行判断，如果cnt[j]大于n说明存在负环使得求最短路时不断循环</p><p>时间复杂度 一般：<span class="math inline">\(O(m)\)</span>最坏：<span class="math inline">\(O(nm)\)</span></p><h3 id="多源汇最短路floyd算法">多源汇最短路Floyd算法</h3><p>时间复杂度 <span class="math inline">\(O(n^3)\)</span></p><pre class="language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N &#x3D; 300;int n, m, k;int dist[N][N];  &#x2F;&#x2F;  注意只需要dist数组，无需g数组void floyd()&#123;    for(int k &#x3D; 1; k &lt;&#x3D; n; k ++ )  &#x2F;&#x2F; k写在最前面        for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )            for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ )                dist[i][j] &#x3D; min(dist[i][j], dist[i][k] + dist[k][j]);      &#x2F;&#x2F; 注意是dist[i][k]+dist[k][j]&#125;int main()&#123;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;    for(int i &#x3D; 1; i &lt;&#x3D; n; i ++ )    &#123;        for(int j &#x3D; 1; j &lt;&#x3D; n; j ++ )        &#123;            if(i &#x3D;&#x3D; j)  dist[i][j] &#x3D; 0;  &#x2F;&#x2F;  不用memset进行初始化            &#x2F;&#x2F;  手动初始化使得dist[i][i] &#x3D; 0            else dist[i][j] &#x3D; 0x3f3f3f3f;        &#125;    &#125;    while(m -- )    &#123;        int a, b, c;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;        dist[a][b] &#x3D; min(dist[a][b], c);  &#x2F;&#x2F; 重边最小化操作    &#125;    floyd();     while(k -- )    &#123;        int a, b;        cin &gt;&gt; a &gt;&gt; b;        if(dist[a][b] &gt; 0x3f3f3f3f &#x2F; 2)  printf(&quot;impossible\n&quot;);        else printf(&quot;%d\n&quot;, dist[a][b]);    &#125;    return 0;&#125;</code></pre>]]></content>
    
    
    <summary type="html">acwing基础课图论笔记</summary>
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="图论" scheme="http://example.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="最短路" scheme="http://example.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>为什么我们都在怀念2019</title>
    <link href="http://example.com/2021/04/25/2019/"/>
    <id>http://example.com/2021/04/25/2019/</id>
    <published>2021-04-25T01:13:15.000Z</published>
    <updated>2022-06-27T09:56:29.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我们为什么都在怀念2019年">我们为什么都在怀念2019年？</h1><p>2022年，却有越来越多的人想要回到2019。</p><p>2019年，第一批90后即将迈入30岁的那年。</p><p>2018年底，美团创始人王兴在他的饭否主页上发了这样一段话。</p><p><img src="https://s2.loli.net/2022/06/27/cUxrSqLudpNhzPy.png" /></p><p>这句话，当时人们是当赛博笑话看的，或者理解成互联网行业例行裁员前的一次舆论铺垫。</p><p>总而言之，人们绝不相信这就是未来10年最好的一年。</p><p>1</p><p>最好的2019，最坏的2019</p><p>从2019年一开始，大家都开心不起来了。</p><p>农历新年前后，青海玉树遭遇了十年一遇的雪灾。</p><p><img src="https://s2.loli.net/2022/06/27/93izVM8fOGCHZvw.gif" /></p><p>受灾人数近60万，有几万只动物在大雪中被埋。</p><p><img src="https://s2.loli.net/2022/06/27/BLNqFJaP5fUsDC1.png" /></p><p>3月30日，四川木里又突发森林大火。</p><p><img src="https://s2.loli.net/2022/06/27/M7ijCXyOVJ8BPoQ.gif" /></p><p>在这场火灾中，有30位烈士离开了我们，其中最小的消防员年仅18岁。</p><p><img src="https://s2.loli.net/2022/06/27/GDUWpk7LXMRK5fY.png" /></p><p>火，在2019年是一个不祥的符号。</p><p>2019年的人类世界，有很多我们所珍视的东西都毁于火焰。</p><p>4月15日，法国巴黎圣母院发生火灾，整座建筑损毁严重。</p><p><img src="https://s2.loli.net/2022/06/27/RKsZT9qwcL8JklP.png" /></p><p>巴黎圣母院的大火让全世界哗然，由此引申出了许多关于政治、宗教与种族的阴谋论。</p><p>但更多的人只是感到遗憾，毕竟作为全人类的文明遗产，自己也许还没来得及去看看。</p><p>同年，又发生了被称为动画界911的“京都动画”纵火案，许多陪伴过我们的作品，与他们的作者和原稿一起永远留在了京阿尼。</p><p><img src="https://s2.loli.net/2022/06/27/bQkPjfYa7nMec8m.png" /></p><p>有人说这是日本经济社会经济长期下行的必然悲剧，也有人为黑白页面的B站番区吵个没完。</p><p><img src="https://s2.loli.net/2022/06/27/oX61st9VwTyDG7Q.png" /></p><p>再之后，令人绝望的大火又长久地盘踞在亚马逊森林，地球之肺险些被烧穿。</p><p><img src="https://s2.loli.net/2022/06/27/XDUSf8H9CI6QmGr.png" /></p><p>·亚马逊火灾卫星图 图源：NASA</p><p>火，不是2019年唯一的苦难。</p><p>3月10日，埃塞俄比亚航空公司一架全新的波音737MAX8客机在起飞6分钟后坠毁，机上149名乘客和8名机组人员全部罹难。</p><p><img src="https://s2.loli.net/2022/06/27/aMhePs2JbAZDYcn.png" /></p><p>4月21日，斯里兰卡首都先后发生8起连环爆炸案，有253人在这次恐怖袭击中丧生，其中6人是中国公民。</p><p><img src="https://s2.loli.net/2022/06/27/f75C8EDmTuhgpQb.png" /></p><p>我们意识到仇恨也是构成人类文明的一部分，这个被技术和协定包裹起来的世界实则动荡不安。</p><p>但是，2019也并非都是坏消息。</p><p>天气和新闻让人焦虑，但我们却从星空中获得了许多慰藉。</p><p>那一年，嫦娥四号传回了人类首张月球背影，我们终于看清了神秘的月之暗面。</p><p><img src="https://s2.loli.net/2022/06/27/Mjd1ZalghQ2miJI.png" /></p><p>紧接着，《流浪地球》上映，无数走进影院的观众高呼，属于中国人的科幻电影时代终于来了。</p><p><img src="https://s2.loli.net/2022/06/27/48dqYzlh6PZWcpS.png" /></p><p>“北京道路安全委提醒你：道路千万条，安全第一条，行车不规范，亲人两行泪。”这句话在全球被以28种语言播放。</p><p><img src="https://s2.loli.net/2022/06/27/oSd1ULwWFXKZ2lP.png" /></p><p>所以很多人把2019称为“中国科幻电影元年”，不过也有人说是“圆寂”的“圆”，因为那一年还上了一部电影叫《上海堡垒》。</p><p>高兴的不只影迷，还有球迷。</p><p>2019年亚洲杯，中国男足2∶1逆转泰国打进八强，给中国人民打了一剂强心针，网上到处都是国足的精彩进球集锦。</p><p><img src="https://s2.loli.net/2022/06/27/u2P5rleOqUJZn7a.jpg" /></p><p>尽管最终不敌伊朗无缘四强，但赛后队长郑智哽咽着道歉还是感动了很多球迷，大家都觉得我们仍有希望。</p><p>2019年，科比来深圳参加了篮球世界杯的抽签仪式，上千名穿着24号队服的球迷在体育馆外大喊：“科比，生儿子。”<imgsrc="https://s2.loli.net/2022/06/27/3nGWZ58TJc4rl2i.png" /></p><p>其实，2019年的世界体坛并不算太平。</p><p>2019年，世界反兴奋剂机构将俄罗斯从国际体育赛事中驱逐四年，我们第一次知道奥运会可以将一整个国家除名。</p><p><img src="https://s2.loli.net/2022/06/27/yT7IhOqZEkXuUFz.png" /></p><p>“我想我们有理由认为这一决定，是出于政治目的”</p><p>不过，紧张中也有松弛。</p><p>那年7月，俄罗斯与乌克兰交换了双方被扣人员，普京说：“这可以视为两国关系正常化的一个步骤。”</p><p><img src="https://s2.loli.net/2022/06/27/dcHyurwC4B5WO8k.png" /></p><p>如果赵本山的小品《昨天 今天明年》是在2019登上春晚，那我想关于这一块他或许会说：</p><p>“国外比较乱套，成天勾心斗角；今天委内瑞拉脱欧，明天奥国首相被炒；闹完贸易战争，又要弹劾领导；纵观世界风云，风景这边独好。”</p><p><img src="https://s2.loli.net/2022/06/27/HTR38SXMzGUF6Vy.png" /></p><p>“电话门”让特朗普在2019年成为美国第三位被弹劾的总统</p><p><strong>然而，彼时这些宏大风云与隐晦征兆，在我们看来或许更像是模糊的时代噪音。</strong></p><p>随着2019年的天气变暖，人们的内心也开始逐渐回温。</p><p>太阳照常升起，我们依旧期待时代的夜晚。</p><p>2</p><p>重逢的年代，告别的年代</p><p>有人说：“2019年，我度过了人生中最浪漫的一个夏天。”</p><p>蒸汽波、CityPop、低保真，日本泡沫经济时代的审美财富，随着中国人均GDP突破一万美元大关，突然在这一年回潮。</p><p><img src="https://s2.loli.net/2022/06/27/ZbQSIFO3grEmo19.gif" /></p><p>“中 国 人 民 真 蒸 汽” 来自B站UP主@鹿堯River</p><p><img src="https://s2.loli.net/2022/06/27/j4ICA3Xw5dNlUFR.gif" /></p><p>2019年,宝石GEM的《野狼Disco》横空出世，重工业港风和蒜味蒸汽波随着全民短视频热，把东北文艺复兴推向高潮。</p><p>社会镜头也忽然重新关注起后工业时代的乡村与城镇，药厂、下班、失落的商场和学校被冠以土法炼钢的缅怀与幽默，中原青年们说要掀起一场华北浪漫革命。</p><p><img src="https://s2.loli.net/2022/06/27/iHDcxvnuNye5FdJ.png" /></p><p>《平原上的夏洛克》（2019）</p><p><strong>90后所经历的时代开始被浪漫化，属于80后的罗曼蒂克也开始限时返场。</strong></p><p>第六代文艺片导演们，在2019年的夏天到来前集中回到大银幕，把过往时代的伤痕凝结成了精致的文化糖霜。</p><p><img src="https://s2.loli.net/2022/06/27/kGXFA5roWcteRO2.png" /></p><p>《地久天长》（2019）</p><p><img src="https://s2.loli.net/2022/06/27/kGXFA5roWcteRO2.png" /></p><p><strong>曾经的理想主义代言人们，也在2019年频繁亮相。</strong></p><p>像韩寒就拍出了《飞驰人生》，沈腾一脚油门带着中年人的青春飞跃巴音布鲁克的海洋。</p><p><img src="https://s2.loli.net/2022/06/27/QfMhOypBqrPUugE.png" /></p><p>·《飞驰人生》2019</p><p>当然，也有理想主义者在2019年黯然离场。</p><p>2019年，罗永浩正式与锤子科技剥离，老罗欠下了银行、合作伙伴和供应商6个亿。</p><p><img src="https://s2.loli.net/2022/06/27/qEnP1ar2W6dzBbH.png" /></p><p>同年，一个叫李佳琦的年轻人靠直播带货赚到了第1个亿，“Oh myGod，买它！”宣告着社交电商已经成为理想主义者的后半场。</p><p><img src="https://s2.loli.net/2022/06/27/fkAuC4FB2adeE7N.png" /></p><h3 id="年是重逢的一年"><strong>2019年，是重逢的一年。</strong></h3><p>解散十多年的Joyside乐队和达达乐队先后宣布重组。</p><p><img src="https://s2.loli.net/2022/06/27/FZWHKk1gzpUSiJ4.jpg" /></p><p>更令人高兴的是，2019年夏天还有一档叫《乐队的夏天》的节目。</p><p><img src="https://s2.loli.net/2022/06/27/FEDyeXv49a3cWuQ.png" /></p><p>在主流视野外游荡多年的中国摇滚乐，终于等到了一次成功的商业化尝试。</p><p>弥留在94红磡遗梦里的摇滚青年们感叹：“中国摇滚乐终于要出圈了！”没有理想的人们或许从此以后不用再伤心了。</p><p><img src="https://s2.loli.net/2022/06/27/3EvQCLXwc27ZS4D.png" /></p><p>然而，不止摇滚乐，所有在那个夏天里跳舞、饮酒，在现场吹着晚风，拥抱朋友的音乐爱好者们当时大概都没料到——<strong>2019年是时间留给他们的最后窗口了</strong>。</p><p><img src="https://s2.loli.net/2022/06/27/8CYMXkKaf1Wp3wx.png" /></p><h3 id="年也是告别的一年"><strong>2019年，也是告别的一年。</strong></h3><p>漫威宇宙第一纪元在这一年迎来终结，超级英雄们在“<strong>我爱你三千遍</strong>”的口号中下岗再就业。</p><p>电影院外如同过年一样的人潮，似乎已经剧透了灭霸响指的失效。</p><p><img src="https://s2.loli.net/2022/06/27/NYRZ3wJLzTEmpKX.png" /></p><p>当然有些告别就明显少了几分诚意与体面，比如《权力的游戏》。</p><p>一个壮阔的故事草草收场，<strong>似乎给21世纪10年代的“终局”开了个坏头儿</strong>。</p><p><img src="https://s2.loli.net/2022/06/27/zZ9xNhuyHbeg8kX.png" /></p><h3id="这一年很多熟悉的人离开了这个世界">这一年，很多熟悉的人离开了这个世界。</h3><p>“糖丸爷爷”顾方舟、“中国氢弹之父”于敏、散文作家林清玄、建筑大师贝聿铭，演员高以翔、崔雪莉、具荷拉......</p><h4id="他们每个人的离去都带走了我们过往生命中的一部分记忆">他们每个人的离去，都带走了我们过往生命中的一部分记忆。</h4><p>日本声优有本钦隆也在这一年辞世，《海贼王》里由他配音的白胡子在退场的时候说</p><p><img src="https://s2.loli.net/2022/06/27/kXNnpIgazEKrc4d.gif" /></p><p><strong>这一年，还有很多漂亮的故事成了梦幻泡影。</strong></p><p>李晨和范冰冰、文章和马伊琍、贾乃亮和李小璐、郑爽和张恒……分手的分手，离婚的离婚，每天打开微博都会有人“<strong>再也不相信爱情了</strong>”。</p><p>出轨风云的吴秀波、学术造假的翟天临，从此以后人设塌房和吃瓜反转成了当代赛博生活的调味剂。</p><p>而在屏幕之外的广阔天地里，有470万对夫妻选择在这一年结束了他们的婚姻关系，结婚人数则创下了十年新低。</p><p><img src="https://s2.loli.net/2022/06/27/x1SFKqB9Lv6wkdC.png" /></p><p>2019年，第一批90后即将迈入30岁。</p><p>然而他们发现，他们没能拥有一个而立的时代。</p><p>758万高校毕业生走出象牙塔，他们成了10年代最后一批能自由进行毕业旅行的年轻人。</p><p>在毕业前夕，他们也第一次听到Jack Ma提及“996是福报”，第一次听RichardLiu说“混日子的人不是我的兄弟”。</p><p>相比第二年未经心理按摩就被投入“<strong>内卷</strong>”大潮中的874万学妹学弟，不知他们是幸运的还是不幸的。</p><p><img src="https://s2.loli.net/2022/06/27/yYplJ9Kx216hOVa.png" /></p><p>2019年的最后一个月，大学生在想着offer和简历，上班族已经开始计算春运抢票的日期。</p><p>面对即将到来的2020，他们都写下了自己对一年的祝愿和期许。</p><p><strong>有些关于生活和爱情，有些关于穿越世界的旅行。</strong></p><p><img src="https://s2.loli.net/2022/06/27/PTUqXudN5f9S7FG.jpg" /></p><p>12月30日晚，网络上忽然蹦出一个在当时看来不太起眼的热搜：</p><h3 id="武汉发现不明原因肺炎">#武汉发现不明原因肺炎</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;我们为什么都在怀念2019年&quot;&gt;我们为什么都在怀念2019年？&lt;/h1&gt;
&lt;p&gt;2022年，却有越来越多的人想要回到2019。&lt;/p&gt;
&lt;p&gt;2019年，第一批90后即将迈入30岁的那年。&lt;/p&gt;
&lt;p&gt;2018年底，美团创始人王兴在他的饭否主页上发了这样一</summary>
      
    
    
    
    <category term="随想" scheme="http://example.com/categories/%E9%9A%8F%E6%83%B3/"/>
    
    
    <category term="思考" scheme="http://example.com/tags/%E6%80%9D%E8%80%83/"/>
    
    <category term="深夜" scheme="http://example.com/tags/%E6%B7%B1%E5%A4%9C/"/>
    
  </entry>
  
</feed>
